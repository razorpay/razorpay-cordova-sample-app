import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone } from '@angular/core';
import { Components } from '@ionic/core';
import type { AccordionGroupChangeEventDetail as IAccordionGroupAccordionGroupChangeEventDetail } from '@ionic/core';
import type { BreadcrumbCollapsedClickEventDetail as IBreadcrumbsBreadcrumbCollapsedClickEventDetail } from '@ionic/core';
import type { CheckboxChangeEventDetail as ICheckboxCheckboxChangeEventDetail } from '@ionic/core';
import type { ScrollBaseDetail as IContentScrollBaseDetail } from '@ionic/core';
import type { ScrollDetail as IContentScrollDetail } from '@ionic/core';
import type { DatetimeChangeEventDetail as IDatetimeDatetimeChangeEventDetail } from '@ionic/core';
import type { InputChangeEventDetail as IInputInputChangeEventDetail } from '@ionic/core';
import type { RadioGroupChangeEventDetail as IRadioGroupRadioGroupChangeEventDetail } from '@ionic/core';
import type { RangeChangeEventDetail as IRangeRangeChangeEventDetail } from '@ionic/core';
import type { RangeKnobMoveStartEventDetail as IRangeRangeKnobMoveStartEventDetail } from '@ionic/core';
import type { RangeKnobMoveEndEventDetail as IRangeRangeKnobMoveEndEventDetail } from '@ionic/core';
import type { RefresherEventDetail as IRefresherRefresherEventDetail } from '@ionic/core';
import type { ItemReorderEventDetail as IReorderGroupItemReorderEventDetail } from '@ionic/core';
import type { SearchbarChangeEventDetail as ISearchbarSearchbarChangeEventDetail } from '@ionic/core';
import type { SegmentChangeEventDetail as ISegmentSegmentChangeEventDetail } from '@ionic/core';
import type { SelectChangeEventDetail as ISelectSelectChangeEventDetail } from '@ionic/core';
import type { TextareaChangeEventDetail as ITextareaTextareaChangeEventDetail } from '@ionic/core';
import type { ToggleChangeEventDetail as IToggleToggleChangeEventDetail } from '@ionic/core';
import * as i0 from "@angular/core";
export declare interface IonAccordion extends Components.IonAccordion {
}
export declare class IonAccordion {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAccordion, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAccordion, "ion-accordion", never, { "disabled": "disabled"; "mode": "mode"; "readonly": "readonly"; "toggleIcon": "toggleIcon"; "toggleIconSlot": "toggleIconSlot"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonAccordionGroup extends Components.IonAccordionGroup {
    /**
     * Emitted when the value property has changed.
     */
    ionChange: EventEmitter<CustomEvent<IAccordionGroupAccordionGroupChangeEventDetail>>;
}
export declare class IonAccordionGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAccordionGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAccordionGroup, "ion-accordion-group", never, { "animated": "animated"; "disabled": "disabled"; "expand": "expand"; "mode": "mode"; "multiple": "multiple"; "readonly": "readonly"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonApp extends Components.IonApp {
}
export declare class IonApp {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonApp, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonApp, "ion-app", never, {}, {}, never, ["*"]>;
}
export declare interface IonAvatar extends Components.IonAvatar {
}
export declare class IonAvatar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonAvatar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonAvatar, "ion-avatar", never, {}, {}, never, ["*"]>;
}
export declare interface IonBackButton extends Components.IonBackButton {
}
export declare class IonBackButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBackButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBackButton, "ion-back-button", never, { "color": "color"; "defaultHref": "defaultHref"; "disabled": "disabled"; "icon": "icon"; "mode": "mode"; "routerAnimation": "routerAnimation"; "text": "text"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonBackdrop extends Components.IonBackdrop {
    /**
     * Emitted when the backdrop is tapped.
     */
    ionBackdropTap: EventEmitter<CustomEvent<void>>;
}
export declare class IonBackdrop {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBackdrop, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBackdrop, "ion-backdrop", never, { "stopPropagation": "stopPropagation"; "tappable": "tappable"; "visible": "visible"; }, {}, never, ["*"]>;
}
export declare interface IonBadge extends Components.IonBadge {
}
export declare class IonBadge {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBadge, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBadge, "ion-badge", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonBreadcrumb extends Components.IonBreadcrumb {
    /**
     * Emitted when the breadcrumb has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the breadcrumb loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonBreadcrumb {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBreadcrumb, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBreadcrumb, "ion-breadcrumb", never, { "active": "active"; "color": "color"; "disabled": "disabled"; "download": "download"; "href": "href"; "mode": "mode"; "rel": "rel"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; "separator": "separator"; "target": "target"; }, {}, never, ["*"]>;
}
export declare interface IonBreadcrumbs extends Components.IonBreadcrumbs {
    /**
     * Emitted when the collapsed indicator is clicked on.
     */
    ionCollapsedClick: EventEmitter<CustomEvent<IBreadcrumbsBreadcrumbCollapsedClickEventDetail>>;
}
export declare class IonBreadcrumbs {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonBreadcrumbs, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonBreadcrumbs, "ion-breadcrumbs", never, { "color": "color"; "itemsAfterCollapse": "itemsAfterCollapse"; "itemsBeforeCollapse": "itemsBeforeCollapse"; "maxItems": "maxItems"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonButton extends Components.IonButton {
    /**
     * Emitted when the button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonButton, "ion-button", never, { "buttonType": "buttonType"; "color": "color"; "disabled": "disabled"; "download": "download"; "expand": "expand"; "fill": "fill"; "href": "href"; "mode": "mode"; "rel": "rel"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; "shape": "shape"; "size": "size"; "strong": "strong"; "target": "target"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonButtons extends Components.IonButtons {
}
export declare class IonButtons {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonButtons, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonButtons, "ion-buttons", never, { "collapse": "collapse"; }, {}, never, ["*"]>;
}
export declare interface IonCard extends Components.IonCard {
}
export declare class IonCard {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCard, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCard, "ion-card", never, { "button": "button"; "color": "color"; "disabled": "disabled"; "download": "download"; "href": "href"; "mode": "mode"; "rel": "rel"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; "target": "target"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonCardContent extends Components.IonCardContent {
}
export declare class IonCardContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardContent, "ion-card-content", never, { "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonCardHeader extends Components.IonCardHeader {
}
export declare class IonCardHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardHeader, "ion-card-header", never, { "color": "color"; "mode": "mode"; "translucent": "translucent"; }, {}, never, ["*"]>;
}
export declare interface IonCardSubtitle extends Components.IonCardSubtitle {
}
export declare class IonCardSubtitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardSubtitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardSubtitle, "ion-card-subtitle", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonCardTitle extends Components.IonCardTitle {
}
export declare class IonCardTitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCardTitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCardTitle, "ion-card-title", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonCheckbox extends Components.IonCheckbox {
    /**
     * Emitted when the checked property has changed.
     */
    ionChange: EventEmitter<CustomEvent<ICheckboxCheckboxChangeEventDetail>>;
    /**
     * Emitted when the checkbox has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the checkbox loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonCheckbox {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCheckbox, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCheckbox, "ion-checkbox", never, { "checked": "checked"; "color": "color"; "disabled": "disabled"; "indeterminate": "indeterminate"; "mode": "mode"; "name": "name"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonChip extends Components.IonChip {
}
export declare class IonChip {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonChip, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonChip, "ion-chip", never, { "color": "color"; "disabled": "disabled"; "mode": "mode"; "outline": "outline"; }, {}, never, ["*"]>;
}
export declare interface IonCol extends Components.IonCol {
}
export declare class IonCol {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonCol, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonCol, "ion-col", never, { "offset": "offset"; "offsetLg": "offsetLg"; "offsetMd": "offsetMd"; "offsetSm": "offsetSm"; "offsetXl": "offsetXl"; "offsetXs": "offsetXs"; "pull": "pull"; "pullLg": "pullLg"; "pullMd": "pullMd"; "pullSm": "pullSm"; "pullXl": "pullXl"; "pullXs": "pullXs"; "push": "push"; "pushLg": "pushLg"; "pushMd": "pushMd"; "pushSm": "pushSm"; "pushXl": "pushXl"; "pushXs": "pushXs"; "size": "size"; "sizeLg": "sizeLg"; "sizeMd": "sizeMd"; "sizeSm": "sizeSm"; "sizeXl": "sizeXl"; "sizeXs": "sizeXs"; }, {}, never, ["*"]>;
}
export declare interface IonContent extends Components.IonContent {
    /**
     * Emitted when the scroll has started. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScrollStart: EventEmitter<CustomEvent<IContentScrollBaseDetail>>;
    /**
     * Emitted while scrolling. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScroll: EventEmitter<CustomEvent<IContentScrollDetail>>;
    /**
     * Emitted when the scroll has ended. This event is disabled by default.
  Set `scrollEvents` to `true` to enable.
     */
    ionScrollEnd: EventEmitter<CustomEvent<IContentScrollBaseDetail>>;
}
export declare class IonContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonContent, "ion-content", never, { "color": "color"; "forceOverscroll": "forceOverscroll"; "fullscreen": "fullscreen"; "scrollEvents": "scrollEvents"; "scrollX": "scrollX"; "scrollY": "scrollY"; }, {}, never, ["*"]>;
}
export declare interface IonDatetime extends Components.IonDatetime {
    /**
     * Emitted when the datetime selection was cancelled.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the value (selected date) has changed.
     */
    ionChange: EventEmitter<CustomEvent<IDatetimeDatetimeChangeEventDetail>>;
    /**
     * Emitted when the datetime has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the datetime loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonDatetime {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonDatetime, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonDatetime, "ion-datetime", never, { "cancelText": "cancelText"; "clearText": "clearText"; "color": "color"; "dayValues": "dayValues"; "disabled": "disabled"; "doneText": "doneText"; "firstDayOfWeek": "firstDayOfWeek"; "hourCycle": "hourCycle"; "hourValues": "hourValues"; "isDateEnabled": "isDateEnabled"; "locale": "locale"; "max": "max"; "min": "min"; "minuteValues": "minuteValues"; "mode": "mode"; "monthValues": "monthValues"; "name": "name"; "presentation": "presentation"; "readonly": "readonly"; "showClearButton": "showClearButton"; "showDefaultButtons": "showDefaultButtons"; "showDefaultTimeLabel": "showDefaultTimeLabel"; "showDefaultTitle": "showDefaultTitle"; "size": "size"; "value": "value"; "yearValues": "yearValues"; }, {}, never, ["*"]>;
}
export declare interface IonFab extends Components.IonFab {
}
export declare class IonFab {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFab, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFab, "ion-fab", never, { "activated": "activated"; "edge": "edge"; "horizontal": "horizontal"; "vertical": "vertical"; }, {}, never, ["*"]>;
}
export declare interface IonFabButton extends Components.IonFabButton {
    /**
     * Emitted when the button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonFabButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFabButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFabButton, "ion-fab-button", never, { "activated": "activated"; "closeIcon": "closeIcon"; "color": "color"; "disabled": "disabled"; "download": "download"; "href": "href"; "mode": "mode"; "rel": "rel"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; "show": "show"; "size": "size"; "target": "target"; "translucent": "translucent"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonFabList extends Components.IonFabList {
}
export declare class IonFabList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFabList, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFabList, "ion-fab-list", never, { "activated": "activated"; "side": "side"; }, {}, never, ["*"]>;
}
export declare interface IonFooter extends Components.IonFooter {
}
export declare class IonFooter {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonFooter, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonFooter, "ion-footer", never, { "collapse": "collapse"; "mode": "mode"; "translucent": "translucent"; }, {}, never, ["*"]>;
}
export declare interface IonGrid extends Components.IonGrid {
}
export declare class IonGrid {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonGrid, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonGrid, "ion-grid", never, { "fixed": "fixed"; }, {}, never, ["*"]>;
}
export declare interface IonHeader extends Components.IonHeader {
}
export declare class IonHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonHeader, "ion-header", never, { "collapse": "collapse"; "mode": "mode"; "translucent": "translucent"; }, {}, never, ["*"]>;
}
export declare interface IonIcon extends Components.IonIcon {
}
export declare class IonIcon {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonIcon, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonIcon, "ion-icon", never, { "color": "color"; "flipRtl": "flipRtl"; "icon": "icon"; "ios": "ios"; "lazy": "lazy"; "md": "md"; "mode": "mode"; "name": "name"; "sanitize": "sanitize"; "size": "size"; "src": "src"; }, {}, never, ["*"]>;
}
export declare interface IonImg extends Components.IonImg {
    /**
     * Emitted when the img src has been set
     */
    ionImgWillLoad: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the image has finished loading
     */
    ionImgDidLoad: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the img fails to load
     */
    ionError: EventEmitter<CustomEvent<void>>;
}
export declare class IonImg {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonImg, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonImg, "ion-img", never, { "alt": "alt"; "src": "src"; }, {}, never, ["*"]>;
}
export declare interface IonInfiniteScroll extends Components.IonInfiniteScroll {
    /**
     * Emitted when the scroll reaches
  the threshold distance. From within your infinite handler,
  you must call the infinite scroll's `complete()` method when
  your async operation has completed.
     */
    ionInfinite: EventEmitter<CustomEvent<void>>;
}
export declare class IonInfiniteScroll {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInfiniteScroll, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInfiniteScroll, "ion-infinite-scroll", never, { "disabled": "disabled"; "position": "position"; "threshold": "threshold"; }, {}, never, ["*"]>;
}
export declare interface IonInfiniteScrollContent extends Components.IonInfiniteScrollContent {
}
export declare class IonInfiniteScrollContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInfiniteScrollContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInfiniteScrollContent, "ion-infinite-scroll-content", never, { "loadingSpinner": "loadingSpinner"; "loadingText": "loadingText"; }, {}, never, ["*"]>;
}
export declare interface IonInput extends Components.IonInput {
    /**
     * Emitted when a keyboard input occurred.
     */
    ionInput: EventEmitter<CustomEvent<InputEvent>>;
    /**
     * Emitted when the value has changed.
     */
    ionChange: EventEmitter<CustomEvent<IInputInputChangeEventDetail>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<FocusEvent>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<FocusEvent>>;
}
export declare class IonInput {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonInput, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonInput, "ion-input", never, { "accept": "accept"; "autocapitalize": "autocapitalize"; "autocomplete": "autocomplete"; "autocorrect": "autocorrect"; "autofocus": "autofocus"; "clearInput": "clearInput"; "clearOnEdit": "clearOnEdit"; "color": "color"; "debounce": "debounce"; "disabled": "disabled"; "enterkeyhint": "enterkeyhint"; "inputmode": "inputmode"; "max": "max"; "maxlength": "maxlength"; "min": "min"; "minlength": "minlength"; "mode": "mode"; "multiple": "multiple"; "name": "name"; "pattern": "pattern"; "placeholder": "placeholder"; "readonly": "readonly"; "required": "required"; "size": "size"; "spellcheck": "spellcheck"; "step": "step"; "type": "type"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonItem extends Components.IonItem {
}
export declare class IonItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItem, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItem, "ion-item", never, { "button": "button"; "color": "color"; "counter": "counter"; "counterFormatter": "counterFormatter"; "detail": "detail"; "detailIcon": "detailIcon"; "disabled": "disabled"; "download": "download"; "fill": "fill"; "href": "href"; "lines": "lines"; "mode": "mode"; "rel": "rel"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; "shape": "shape"; "target": "target"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonItemDivider extends Components.IonItemDivider {
}
export declare class IonItemDivider {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemDivider, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemDivider, "ion-item-divider", never, { "color": "color"; "mode": "mode"; "sticky": "sticky"; }, {}, never, ["*"]>;
}
export declare interface IonItemGroup extends Components.IonItemGroup {
}
export declare class IonItemGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemGroup, "ion-item-group", never, {}, {}, never, ["*"]>;
}
export declare interface IonItemOption extends Components.IonItemOption {
}
export declare class IonItemOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemOption, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemOption, "ion-item-option", never, { "color": "color"; "disabled": "disabled"; "download": "download"; "expandable": "expandable"; "href": "href"; "mode": "mode"; "rel": "rel"; "target": "target"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonItemOptions extends Components.IonItemOptions {
    /**
     * Emitted when the item has been fully swiped.
     */
    ionSwipe: EventEmitter<CustomEvent<any>>;
}
export declare class IonItemOptions {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemOptions, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemOptions, "ion-item-options", never, { "side": "side"; }, {}, never, ["*"]>;
}
export declare interface IonItemSliding extends Components.IonItemSliding {
    /**
     * Emitted when the sliding position changes.
     */
    ionDrag: EventEmitter<CustomEvent<any>>;
}
export declare class IonItemSliding {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonItemSliding, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonItemSliding, "ion-item-sliding", never, { "disabled": "disabled"; }, {}, never, ["*"]>;
}
export declare interface IonLabel extends Components.IonLabel {
}
export declare class IonLabel {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonLabel, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonLabel, "ion-label", never, { "color": "color"; "mode": "mode"; "position": "position"; }, {}, never, ["*"]>;
}
export declare interface IonList extends Components.IonList {
}
export declare class IonList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonList, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonList, "ion-list", never, { "inset": "inset"; "lines": "lines"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonListHeader extends Components.IonListHeader {
}
export declare class IonListHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonListHeader, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonListHeader, "ion-list-header", never, { "color": "color"; "lines": "lines"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonMenu extends Components.IonMenu {
    /**
     * Emitted when the menu is about to be opened.
     */
    ionWillOpen: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the menu is about to be closed.
     */
    ionWillClose: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the menu is open.
     */
    ionDidOpen: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the menu is closed.
     */
    ionDidClose: EventEmitter<CustomEvent<void>>;
}
export declare class IonMenu {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenu, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenu, "ion-menu", never, { "contentId": "contentId"; "disabled": "disabled"; "maxEdgeStart": "maxEdgeStart"; "menuId": "menuId"; "side": "side"; "swipeGesture": "swipeGesture"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonMenuButton extends Components.IonMenuButton {
}
export declare class IonMenuButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenuButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenuButton, "ion-menu-button", never, { "autoHide": "autoHide"; "color": "color"; "disabled": "disabled"; "menu": "menu"; "mode": "mode"; "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonMenuToggle extends Components.IonMenuToggle {
}
export declare class IonMenuToggle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonMenuToggle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonMenuToggle, "ion-menu-toggle", never, { "autoHide": "autoHide"; "menu": "menu"; }, {}, never, ["*"]>;
}
export declare interface IonNav extends Components.IonNav {
    /**
     * Event fired when the nav will change components
     */
    ionNavWillChange: EventEmitter<CustomEvent<void>>;
    /**
     * Event fired when the nav has changed components
     */
    ionNavDidChange: EventEmitter<CustomEvent<void>>;
}
export declare class IonNav {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonNav, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonNav, "ion-nav", never, { "animated": "animated"; "animation": "animation"; "root": "root"; "rootParams": "rootParams"; "swipeGesture": "swipeGesture"; }, {}, never, ["*"]>;
}
export declare interface IonNavLink extends Components.IonNavLink {
}
export declare class IonNavLink {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonNavLink, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonNavLink, "ion-nav-link", never, { "component": "component"; "componentProps": "componentProps"; "routerAnimation": "routerAnimation"; "routerDirection": "routerDirection"; }, {}, never, ["*"]>;
}
export declare interface IonNote extends Components.IonNote {
}
export declare class IonNote {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonNote, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonNote, "ion-note", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonProgressBar extends Components.IonProgressBar {
}
export declare class IonProgressBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonProgressBar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonProgressBar, "ion-progress-bar", never, { "buffer": "buffer"; "color": "color"; "mode": "mode"; "reversed": "reversed"; "type": "type"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonRadio extends Components.IonRadio {
    /**
     * Emitted when the radio button has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the radio button loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonRadio {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRadio, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRadio, "ion-radio", never, { "color": "color"; "disabled": "disabled"; "mode": "mode"; "name": "name"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonRadioGroup extends Components.IonRadioGroup {
    /**
     * Emitted when the value has changed.
     */
    ionChange: EventEmitter<CustomEvent<IRadioGroupRadioGroupChangeEventDetail>>;
}
export declare class IonRadioGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRadioGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRadioGroup, "ion-radio-group", never, { "allowEmptySelection": "allowEmptySelection"; "name": "name"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonRange extends Components.IonRange {
    /**
     * Emitted when the value property has changed.
     */
    ionChange: EventEmitter<CustomEvent<IRangeRangeChangeEventDetail>>;
    /**
     * Emitted when the range has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the range loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user starts moving the range knob, whether through
  mouse drag, touch gesture, or keyboard interaction.
     */
    ionKnobMoveStart: EventEmitter<CustomEvent<IRangeRangeKnobMoveStartEventDetail>>;
    /**
     * Emitted when the user finishes moving the range knob, whether through
  mouse drag, touch gesture, or keyboard interaction.
     */
    ionKnobMoveEnd: EventEmitter<CustomEvent<IRangeRangeKnobMoveEndEventDetail>>;
}
export declare class IonRange {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRange, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRange, "ion-range", never, { "color": "color"; "debounce": "debounce"; "disabled": "disabled"; "dualKnobs": "dualKnobs"; "max": "max"; "min": "min"; "mode": "mode"; "name": "name"; "pin": "pin"; "pinFormatter": "pinFormatter"; "snaps": "snaps"; "step": "step"; "ticks": "ticks"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonRefresher extends Components.IonRefresher {
    /**
     * Emitted when the user lets go of the content and has pulled down
  further than the `pullMin` or pulls the content down and exceeds the pullMax.
  Updates the refresher state to `refreshing`. The `complete()` method should be
  called when the async operation has completed.
     */
    ionRefresh: EventEmitter<CustomEvent<IRefresherRefresherEventDetail>>;
    /**
     * Emitted while the user is pulling down the content and exposing the refresher.
     */
    ionPull: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user begins to start pulling down.
     */
    ionStart: EventEmitter<CustomEvent<void>>;
}
export declare class IonRefresher {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRefresher, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRefresher, "ion-refresher", never, { "closeDuration": "closeDuration"; "disabled": "disabled"; "pullFactor": "pullFactor"; "pullMax": "pullMax"; "pullMin": "pullMin"; "snapbackDuration": "snapbackDuration"; }, {}, never, ["*"]>;
}
export declare interface IonRefresherContent extends Components.IonRefresherContent {
}
export declare class IonRefresherContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRefresherContent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRefresherContent, "ion-refresher-content", never, { "pullingIcon": "pullingIcon"; "pullingText": "pullingText"; "refreshingSpinner": "refreshingSpinner"; "refreshingText": "refreshingText"; }, {}, never, ["*"]>;
}
export declare interface IonReorder extends Components.IonReorder {
}
export declare class IonReorder {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonReorder, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonReorder, "ion-reorder", never, {}, {}, never, ["*"]>;
}
export declare interface IonReorderGroup extends Components.IonReorderGroup {
    /**
     * Event that needs to be listened to in order to complete the reorder action.
  Once the event has been emitted, the `complete()` method then needs
  to be called in order to finalize the reorder action.
     */
    ionItemReorder: EventEmitter<CustomEvent<IReorderGroupItemReorderEventDetail>>;
}
export declare class IonReorderGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonReorderGroup, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonReorderGroup, "ion-reorder-group", never, { "disabled": "disabled"; }, {}, never, ["*"]>;
}
export declare interface IonRippleEffect extends Components.IonRippleEffect {
}
export declare class IonRippleEffect {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRippleEffect, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRippleEffect, "ion-ripple-effect", never, { "type": "type"; }, {}, never, ["*"]>;
}
export declare interface IonRow extends Components.IonRow {
}
export declare class IonRow {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonRow, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonRow, "ion-row", never, {}, {}, never, ["*"]>;
}
export declare interface IonSearchbar extends Components.IonSearchbar {
    /**
     * Emitted when a keyboard input occurred.
     */
    ionInput: EventEmitter<CustomEvent<KeyboardEvent>>;
    /**
     * Emitted when the value has changed.
     */
    ionChange: EventEmitter<CustomEvent<ISearchbarSearchbarChangeEventDetail>>;
    /**
     * Emitted when the cancel button is clicked.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the clear input button is clicked.
     */
    ionClear: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
}
export declare class IonSearchbar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSearchbar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSearchbar, "ion-searchbar", never, { "animated": "animated"; "autocomplete": "autocomplete"; "autocorrect": "autocorrect"; "cancelButtonIcon": "cancelButtonIcon"; "cancelButtonText": "cancelButtonText"; "clearIcon": "clearIcon"; "color": "color"; "debounce": "debounce"; "disabled": "disabled"; "enterkeyhint": "enterkeyhint"; "inputmode": "inputmode"; "mode": "mode"; "placeholder": "placeholder"; "searchIcon": "searchIcon"; "showCancelButton": "showCancelButton"; "showClearButton": "showClearButton"; "spellcheck": "spellcheck"; "type": "type"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonSegment extends Components.IonSegment {
    /**
     * Emitted when the value property has changed and any
  dragging pointer has been released from `ion-segment`.
     */
    ionChange: EventEmitter<CustomEvent<ISegmentSegmentChangeEventDetail>>;
}
export declare class IonSegment {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegment, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegment, "ion-segment", never, { "color": "color"; "disabled": "disabled"; "mode": "mode"; "scrollable": "scrollable"; "selectOnFocus": "selectOnFocus"; "swipeGesture": "swipeGesture"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonSegmentButton extends Components.IonSegmentButton {
}
export declare class IonSegmentButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSegmentButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSegmentButton, "ion-segment-button", never, { "disabled": "disabled"; "layout": "layout"; "mode": "mode"; "type": "type"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonSelect extends Components.IonSelect {
    /**
     * Emitted when the value has changed.
     */
    ionChange: EventEmitter<CustomEvent<ISelectSelectChangeEventDetail>>;
    /**
     * Emitted when the selection is cancelled.
     */
    ionCancel: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the overlay is dismissed.
     */
    ionDismiss: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the select has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the select loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonSelect {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSelect, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSelect, "ion-select", never, { "cancelText": "cancelText"; "compareWith": "compareWith"; "disabled": "disabled"; "interface": "interface"; "interfaceOptions": "interfaceOptions"; "mode": "mode"; "multiple": "multiple"; "name": "name"; "okText": "okText"; "placeholder": "placeholder"; "selectedText": "selectedText"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonSelectOption extends Components.IonSelectOption {
}
export declare class IonSelectOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSelectOption, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSelectOption, "ion-select-option", never, { "disabled": "disabled"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonSkeletonText extends Components.IonSkeletonText {
}
export declare class IonSkeletonText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSkeletonText, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSkeletonText, "ion-skeleton-text", never, { "animated": "animated"; }, {}, never, ["*"]>;
}
export declare interface IonSlide extends Components.IonSlide {
}
export declare class IonSlide {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSlide, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSlide, "ion-slide", never, {}, {}, never, ["*"]>;
}
export declare interface IonSlides extends Components.IonSlides {
    /**
     * Emitted after Swiper initialization
     */
    ionSlidesDidLoad: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user taps/clicks on the slide's container.
     */
    ionSlideTap: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user double taps on the slide's container.
     */
    ionSlideDoubleTap: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted before the active slide has changed.
     */
    ionSlideWillChange: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted after the active slide has changed.
     */
    ionSlideDidChange: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the next slide has started.
     */
    ionSlideNextStart: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the previous slide has started.
     */
    ionSlidePrevStart: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the next slide has ended.
     */
    ionSlideNextEnd: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the previous slide has ended.
     */
    ionSlidePrevEnd: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the slide transition has started.
     */
    ionSlideTransitionStart: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the slide transition has ended.
     */
    ionSlideTransitionEnd: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the slider is actively being moved.
     */
    ionSlideDrag: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the slider is at its initial position.
     */
    ionSlideReachStart: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the slider is at the last slide.
     */
    ionSlideReachEnd: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user first touches the slider.
     */
    ionSlideTouchStart: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the user releases the touch.
     */
    ionSlideTouchEnd: EventEmitter<CustomEvent<void>>;
}
export declare class IonSlides {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSlides, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSlides, "ion-slides", never, { "mode": "mode"; "options": "options"; "pager": "pager"; "scrollbar": "scrollbar"; }, {}, never, ["*"]>;
}
export declare interface IonSpinner extends Components.IonSpinner {
}
export declare class IonSpinner {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSpinner, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSpinner, "ion-spinner", never, { "color": "color"; "duration": "duration"; "name": "name"; "paused": "paused"; }, {}, never, ["*"]>;
}
export declare interface IonSplitPane extends Components.IonSplitPane {
    /**
     * Expression to be called when the split-pane visibility has changed
     */
    ionSplitPaneVisible: EventEmitter<CustomEvent<{
        visible: boolean;
    }>>;
}
export declare class IonSplitPane {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonSplitPane, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonSplitPane, "ion-split-pane", never, { "contentId": "contentId"; "disabled": "disabled"; "when": "when"; }, {}, never, ["*"]>;
}
export declare interface IonTabBar extends Components.IonTabBar {
}
export declare class IonTabBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTabBar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTabBar, "ion-tab-bar", never, { "color": "color"; "mode": "mode"; "selectedTab": "selectedTab"; "translucent": "translucent"; }, {}, never, ["*"]>;
}
export declare interface IonTabButton extends Components.IonTabButton {
}
export declare class IonTabButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTabButton, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTabButton, "ion-tab-button", never, { "disabled": "disabled"; "download": "download"; "href": "href"; "layout": "layout"; "mode": "mode"; "rel": "rel"; "selected": "selected"; "tab": "tab"; "target": "target"; }, {}, never, ["*"]>;
}
export declare interface IonText extends Components.IonText {
}
export declare class IonText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonText, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonText, "ion-text", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
export declare interface IonTextarea extends Components.IonTextarea {
    /**
     * Emitted when the input value has changed.
     */
    ionChange: EventEmitter<CustomEvent<ITextareaTextareaChangeEventDetail>>;
    /**
     * Emitted when a keyboard input occurred.
     */
    ionInput: EventEmitter<CustomEvent<InputEvent>>;
    /**
     * Emitted when the input loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<FocusEvent>>;
    /**
     * Emitted when the input has focus.
     */
    ionFocus: EventEmitter<CustomEvent<FocusEvent>>;
}
export declare class IonTextarea {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTextarea, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTextarea, "ion-textarea", never, { "autoGrow": "autoGrow"; "autocapitalize": "autocapitalize"; "autofocus": "autofocus"; "clearOnEdit": "clearOnEdit"; "color": "color"; "cols": "cols"; "debounce": "debounce"; "disabled": "disabled"; "enterkeyhint": "enterkeyhint"; "inputmode": "inputmode"; "maxlength": "maxlength"; "minlength": "minlength"; "mode": "mode"; "name": "name"; "placeholder": "placeholder"; "readonly": "readonly"; "required": "required"; "rows": "rows"; "spellcheck": "spellcheck"; "value": "value"; "wrap": "wrap"; }, {}, never, ["*"]>;
}
export declare interface IonThumbnail extends Components.IonThumbnail {
}
export declare class IonThumbnail {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonThumbnail, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonThumbnail, "ion-thumbnail", never, {}, {}, never, ["*"]>;
}
export declare interface IonTitle extends Components.IonTitle {
}
export declare class IonTitle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonTitle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonTitle, "ion-title", never, { "color": "color"; "size": "size"; }, {}, never, ["*"]>;
}
export declare interface IonToggle extends Components.IonToggle {
    /**
     * Emitted when the value property has changed.
     */
    ionChange: EventEmitter<CustomEvent<IToggleToggleChangeEventDetail>>;
    /**
     * Emitted when the toggle has focus.
     */
    ionFocus: EventEmitter<CustomEvent<void>>;
    /**
     * Emitted when the toggle loses focus.
     */
    ionBlur: EventEmitter<CustomEvent<void>>;
}
export declare class IonToggle {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonToggle, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonToggle, "ion-toggle", never, { "checked": "checked"; "color": "color"; "disabled": "disabled"; "mode": "mode"; "name": "name"; "value": "value"; }, {}, never, ["*"]>;
}
export declare interface IonToolbar extends Components.IonToolbar {
}
export declare class IonToolbar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: i0.ɵɵFactoryDeclaration<IonToolbar, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<IonToolbar, "ion-toolbar", never, { "color": "color"; "mode": "mode"; }, {}, never, ["*"]>;
}
