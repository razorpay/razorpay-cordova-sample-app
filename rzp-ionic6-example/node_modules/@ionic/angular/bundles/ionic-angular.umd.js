(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('rxjs'), require('@angular/router'), require('@ionic/core'), require('rxjs/operators'), require('@angular/common'), require('@ionic/core/loader')) :
    typeof define === 'function' && define.amd ? define('@ionic/angular', ['exports', '@angular/core', '@angular/forms', 'rxjs', '@angular/router', '@ionic/core', 'rxjs/operators', '@angular/common', '@ionic/core/loader'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ionic = global.ionic || {}, global.ionic.angular = {}), global.ng.core, global.ng.forms, global.rxjs, global.ng.router, global.core, global.rxjs.operators, global.ng.common, global.loader));
})(this, (function (exports, i0, forms, rxjs, i3, core, operators, i1, loader) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var raf = function (h) {
        if (typeof __zone_symbol__requestAnimationFrame === 'function') {
            return __zone_symbol__requestAnimationFrame(h);
        }
        if (typeof requestAnimationFrame === 'function') {
            return requestAnimationFrame(h);
        }
        return setTimeout(h);
    };
    var isComponentFactoryResolver = function (item) {
        return !!item.resolveComponentFactory;
    };

    var ValueAccessor = /** @class */ (function () {
        function ValueAccessor(injector, el) {
            this.injector = injector;
            this.el = el;
            this.onChange = function () {
                /**/
            };
            this.onTouched = function () {
                /**/
            };
        }
        ValueAccessor.prototype.writeValue = function (value) {
            /**
             * TODO for Ionic 6:
             * Change `value == null ? '' : value;`
             * to `value`. This was a fix for IE9, but IE9
             * is no longer supported; however, this change
             * is potentially a breaking change
             */
            this.el.nativeElement.value = this.lastValue = value == null ? '' : value;
            setIonicClasses(this.el);
        };
        ValueAccessor.prototype.handleChangeEvent = function (el, value) {
            if (el === this.el.nativeElement) {
                if (value !== this.lastValue) {
                    this.lastValue = value;
                    this.onChange(value);
                }
                setIonicClasses(this.el);
            }
        };
        ValueAccessor.prototype._handleBlurEvent = function (el) {
            if (el === this.el.nativeElement) {
                this.onTouched();
                setIonicClasses(this.el);
            }
        };
        ValueAccessor.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        ValueAccessor.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        ValueAccessor.prototype.setDisabledState = function (isDisabled) {
            this.el.nativeElement.disabled = isDisabled;
        };
        ValueAccessor.prototype.ngOnDestroy = function () {
            if (this.statusChanges) {
                this.statusChanges.unsubscribe();
            }
        };
        ValueAccessor.prototype.ngAfterViewInit = function () {
            var _this = this;
            var ngControl;
            try {
                ngControl = this.injector.get(forms.NgControl);
            }
            catch (_a) {
                /* No FormControl or ngModel binding */
            }
            if (!ngControl) {
                return;
            }
            // Listen for changes in validity, disabled, or pending states
            if (ngControl.statusChanges) {
                this.statusChanges = ngControl.statusChanges.subscribe(function () { return setIonicClasses(_this.el); });
            }
            /**
             * TODO Remove this in favor of https://github.com/angular/angular/issues/10887
             * whenever it is implemented. Currently, Ionic's form status classes
             * do not react to changes when developers manually call
             * Angular form control methods such as markAsTouched.
             * This results in Ionic's form status classes being out
             * of sync with the ng form status classes.
             * This patches the methods to manually sync
             * the classes until this feature is implemented in Angular.
             */
            var formControl = ngControl.control;
            if (formControl) {
                var methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];
                methodsToPatch.forEach(function (method) {
                    if (typeof formControl[method] !== 'undefined') {
                        var oldFn_1 = formControl[method].bind(formControl);
                        formControl[method] = function () {
                            var params = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                params[_i] = arguments[_i];
                            }
                            oldFn_1.apply(void 0, __spreadArray([], __read(params)));
                            setIonicClasses(_this.el);
                        };
                    }
                });
            }
        };
        return ValueAccessor;
    }());
    /** @nocollapse */ ValueAccessor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ValueAccessor, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ ValueAccessor.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: ValueAccessor, host: { listeners: { "ionBlur": "_handleBlurEvent($event.target)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ValueAccessor, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleBlurEvent: [{
                    type: i0.HostListener,
                    args: ['ionBlur', ['$event.target']]
                }] } });
    var setIonicClasses = function (element) {
        raf(function () {
            var input = element.nativeElement;
            var hasValue = input.value != null && input.value.toString().length > 0;
            var classes = getClasses(input);
            setClasses(input, classes);
            var item = input.closest('ion-item');
            if (item) {
                if (hasValue) {
                    setClasses(item, __spreadArray(__spreadArray([], __read(classes)), ['item-has-value']));
                }
                else {
                    setClasses(item, classes);
                }
            }
        });
    };
    var getClasses = function (element) {
        var classList = element.classList;
        var classes = [];
        for (var i = 0; i < classList.length; i++) {
            var item = classList.item(i);
            if (item !== null && startsWith(item, 'ng-')) {
                classes.push("ion-" + item.substring(3));
            }
        }
        return classes;
    };
    var setClasses = function (element, classes) {
        var classList = element.classList;
        classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');
        classList.add.apply(classList, __spreadArray([], __read(classes)));
    };
    var startsWith = function (input, search) {
        return input.substring(0, search.length) === search;
    };

    var BooleanValueAccessorDirective = /** @class */ (function (_super) {
        __extends(BooleanValueAccessorDirective, _super);
        function BooleanValueAccessorDirective(injector, el) {
            return _super.call(this, injector, el) || this;
        }
        BooleanValueAccessorDirective.prototype.writeValue = function (value) {
            this.el.nativeElement.checked = this.lastValue = value == null ? false : value;
            setIonicClasses(this.el);
        };
        BooleanValueAccessorDirective.prototype._handleIonChange = function (el) {
            this.handleChangeEvent(el, el.checked);
        };
        return BooleanValueAccessorDirective;
    }(ValueAccessor));
    /** @nocollapse */ BooleanValueAccessorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: BooleanValueAccessorDirective, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ BooleanValueAccessorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: BooleanValueAccessorDirective, selector: "ion-checkbox,ion-toggle", host: { listeners: { "ionChange": "_handleIonChange($event.target)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: BooleanValueAccessorDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: BooleanValueAccessorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ion-checkbox,ion-toggle',
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: BooleanValueAccessorDirective,
                                multi: true,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleIonChange: [{
                    type: i0.HostListener,
                    args: ['ionChange', ['$event.target']]
                }] } });

    var NumericValueAccessorDirective = /** @class */ (function (_super) {
        __extends(NumericValueAccessorDirective, _super);
        function NumericValueAccessorDirective(injector, el) {
            return _super.call(this, injector, el) || this;
        }
        NumericValueAccessorDirective.prototype._handleIonChange = function (el) {
            this.handleChangeEvent(el, el.value);
        };
        NumericValueAccessorDirective.prototype.registerOnChange = function (fn) {
            _super.prototype.registerOnChange.call(this, function (value) {
                fn(value === '' ? null : parseFloat(value));
            });
        };
        return NumericValueAccessorDirective;
    }(ValueAccessor));
    /** @nocollapse */ NumericValueAccessorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: NumericValueAccessorDirective, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ NumericValueAccessorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: NumericValueAccessorDirective, selector: "ion-input[type=number]", host: { listeners: { "ionChange": "_handleIonChange($event.target)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: NumericValueAccessorDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: NumericValueAccessorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ion-input[type=number]',
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: NumericValueAccessorDirective,
                                multi: true,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleIonChange: [{
                    type: i0.HostListener,
                    args: ['ionChange', ['$event.target']]
                }] } });

    var RadioValueAccessorDirective = /** @class */ (function (_super) {
        __extends(RadioValueAccessorDirective, _super);
        function RadioValueAccessorDirective(injector, el) {
            return _super.call(this, injector, el) || this;
        }
        RadioValueAccessorDirective.prototype._handleIonSelect = function (el) {
            this.handleChangeEvent(el, el.checked);
        };
        return RadioValueAccessorDirective;
    }(ValueAccessor));
    /** @nocollapse */ RadioValueAccessorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RadioValueAccessorDirective, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ RadioValueAccessorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: RadioValueAccessorDirective, selector: "ion-radio", host: { listeners: { "ionSelect": "_handleIonSelect($event.target)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: RadioValueAccessorDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RadioValueAccessorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        /* tslint:disable-next-line:directive-selector */
                        selector: 'ion-radio',
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: RadioValueAccessorDirective,
                                multi: true,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleIonSelect: [{
                    type: i0.HostListener,
                    args: ['ionSelect', ['$event.target']]
                }] } });

    var SelectValueAccessorDirective = /** @class */ (function (_super) {
        __extends(SelectValueAccessorDirective, _super);
        function SelectValueAccessorDirective(injector, el) {
            return _super.call(this, injector, el) || this;
        }
        SelectValueAccessorDirective.prototype._handleChangeEvent = function (el) {
            this.handleChangeEvent(el, el.value);
        };
        return SelectValueAccessorDirective;
    }(ValueAccessor));
    /** @nocollapse */ SelectValueAccessorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: SelectValueAccessorDirective, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ SelectValueAccessorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: SelectValueAccessorDirective, selector: "ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime", host: { listeners: { "ionChange": "_handleChangeEvent($event.target)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: SelectValueAccessorDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: SelectValueAccessorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        /* tslint:disable-next-line:directive-selector */
                        selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: SelectValueAccessorDirective,
                                multi: true,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleChangeEvent: [{
                    type: i0.HostListener,
                    args: ['ionChange', ['$event.target']]
                }] } });

    var TextValueAccessorDirective = /** @class */ (function (_super) {
        __extends(TextValueAccessorDirective, _super);
        function TextValueAccessorDirective(injector, el) {
            return _super.call(this, injector, el) || this;
        }
        TextValueAccessorDirective.prototype._handleInputEvent = function (el) {
            this.handleChangeEvent(el, el.value);
        };
        return TextValueAccessorDirective;
    }(ValueAccessor));
    /** @nocollapse */ TextValueAccessorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: TextValueAccessorDirective, deps: [{ token: i0__namespace.Injector }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ TextValueAccessorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: TextValueAccessorDirective, selector: "ion-input:not([type=number]),ion-textarea,ion-searchbar", host: { listeners: { "ionChange": "_handleInputEvent($event.target)" } }, providers: [
            {
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: TextValueAccessorDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: TextValueAccessorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        /* tslint:disable-next-line:directive-selector */
                        selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: TextValueAccessorDirective,
                                multi: true,
                            },
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Injector }, { type: i0__namespace.ElementRef }]; }, propDecorators: { _handleInputEvent: [{
                    type: i0.HostListener,
                    args: ['ionChange', ['$event.target']]
                }] } });

    /* eslint-disable */
    var proxyInputs = function (Cmp, inputs) {
        var Prototype = Cmp.prototype;
        inputs.forEach(function (item) {
            Object.defineProperty(Prototype, item, {
                get: function () {
                    return this.el[item];
                },
                set: function (val) {
                    var _this = this;
                    this.z.runOutsideAngular(function () { return (_this.el[item] = val); });
                }
            });
        });
    };
    var proxyMethods = function (Cmp, methods) {
        var Prototype = Cmp.prototype;
        methods.forEach(function (methodName) {
            Prototype[methodName] = function () {
                var _this = this;
                var args = arguments;
                return this.z.runOutsideAngular(function () { return _this.el[methodName].apply(_this.el, args); });
            };
        });
    };
    var proxyOutputs = function (instance, el, events) {
        events.forEach(function (eventName) { return instance[eventName] = rxjs.fromEvent(el, eventName); });
    };
    var defineCustomElement = function (tagName, customElement) {
        if (customElement !== undefined &&
            typeof customElements !== 'undefined' &&
            !customElements.get(tagName)) {
            customElements.define(tagName, customElement);
        }
    };
    // tslint:disable-next-line: only-arrow-functions
    function ProxyCmp(opts) {
        var decorator = function (cls) {
            var defineCustomElementFn = opts.defineCustomElementFn, inputs = opts.inputs, methods = opts.methods;
            if (defineCustomElementFn !== undefined) {
                defineCustomElementFn();
            }
            if (inputs) {
                proxyInputs(cls, inputs);
            }
            if (methods) {
                proxyMethods(cls, methods);
            }
            return cls;
        };
        return decorator;
    }

    exports.IonAccordion = /** @class */ (function () {
        function IonAccordion(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonAccordion;
    }());
    /** @nocollapse */ exports.IonAccordion.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAccordion, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonAccordion.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonAccordion, selector: "ion-accordion", inputs: { disabled: "disabled", mode: "mode", readonly: "readonly", toggleIcon: "toggleIcon", toggleIconSlot: "toggleIconSlot", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonAccordion = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled', 'mode', 'readonly', 'toggleIcon', 'toggleIconSlot', 'value']
        })
    ], exports.IonAccordion);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAccordion, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-accordion',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled', 'mode', 'readonly', 'toggleIcon', 'toggleIconSlot', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonAccordionGroup = /** @class */ (function () {
        function IonAccordionGroup(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange']);
        }
        return IonAccordionGroup;
    }());
    /** @nocollapse */ exports.IonAccordionGroup.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAccordionGroup, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonAccordionGroup.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonAccordionGroup, selector: "ion-accordion-group", inputs: { animated: "animated", disabled: "disabled", expand: "expand", mode: "mode", multiple: "multiple", readonly: "readonly", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonAccordionGroup = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['animated', 'disabled', 'expand', 'mode', 'multiple', 'readonly', 'value']
        })
    ], exports.IonAccordionGroup);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAccordionGroup, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-accordion-group',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['animated', 'disabled', 'expand', 'mode', 'multiple', 'readonly', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonApp = /** @class */ (function () {
        function IonApp(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonApp;
    }());
    /** @nocollapse */ exports.IonApp.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonApp, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonApp.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonApp, selector: "ion-app", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonApp = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonApp);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonApp, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-app',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonAvatar = /** @class */ (function () {
        function IonAvatar(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonAvatar;
    }());
    /** @nocollapse */ exports.IonAvatar.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAvatar, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonAvatar.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonAvatar, selector: "ion-avatar", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonAvatar = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonAvatar);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonAvatar, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-avatar',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonBackButton = /** @class */ (function () {
        function IonBackButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonBackButton;
    }());
    /** @nocollapse */ exports.IonBackButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBackButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonBackButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonBackButton, selector: "ion-back-button", inputs: { color: "color", defaultHref: "defaultHref", disabled: "disabled", icon: "icon", mode: "mode", routerAnimation: "routerAnimation", text: "text", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonBackButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type']
        })
    ], exports.IonBackButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBackButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-back-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonBackdrop = /** @class */ (function () {
        function IonBackdrop(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionBackdropTap']);
        }
        return IonBackdrop;
    }());
    /** @nocollapse */ exports.IonBackdrop.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBackdrop, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonBackdrop.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonBackdrop, selector: "ion-backdrop", inputs: { stopPropagation: "stopPropagation", tappable: "tappable", visible: "visible" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonBackdrop = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['stopPropagation', 'tappable', 'visible']
        })
    ], exports.IonBackdrop);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBackdrop, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-backdrop',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['stopPropagation', 'tappable', 'visible']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonBadge = /** @class */ (function () {
        function IonBadge(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonBadge;
    }());
    /** @nocollapse */ exports.IonBadge.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBadge, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonBadge.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonBadge, selector: "ion-badge", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonBadge = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonBadge);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBadge, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-badge',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonBreadcrumb = /** @class */ (function () {
        function IonBreadcrumb(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
        }
        return IonBreadcrumb;
    }());
    /** @nocollapse */ exports.IonBreadcrumb.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBreadcrumb, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonBreadcrumb.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonBreadcrumb, selector: "ion-breadcrumb", inputs: { active: "active", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", separator: "separator", target: "target" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonBreadcrumb = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['active', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'separator', 'target']
        })
    ], exports.IonBreadcrumb);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBreadcrumb, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-breadcrumb',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['active', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'separator', 'target']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonBreadcrumbs = /** @class */ (function () {
        function IonBreadcrumbs(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionCollapsedClick']);
        }
        return IonBreadcrumbs;
    }());
    /** @nocollapse */ exports.IonBreadcrumbs.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBreadcrumbs, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonBreadcrumbs.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonBreadcrumbs, selector: "ion-breadcrumbs", inputs: { color: "color", itemsAfterCollapse: "itemsAfterCollapse", itemsBeforeCollapse: "itemsBeforeCollapse", maxItems: "maxItems", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonBreadcrumbs = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'itemsAfterCollapse', 'itemsBeforeCollapse', 'maxItems', 'mode']
        })
    ], exports.IonBreadcrumbs);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonBreadcrumbs, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-breadcrumbs',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'itemsAfterCollapse', 'itemsBeforeCollapse', 'maxItems', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonButton = /** @class */ (function () {
        function IonButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
        }
        return IonButton;
    }());
    /** @nocollapse */ exports.IonButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonButton, selector: "ion-button", inputs: { buttonType: "buttonType", color: "color", disabled: "disabled", download: "download", expand: "expand", fill: "fill", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", shape: "shape", size: "size", strong: "strong", target: "target", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']
        })
    ], exports.IonButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonButtons = /** @class */ (function () {
        function IonButtons(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonButtons;
    }());
    /** @nocollapse */ exports.IonButtons.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonButtons, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonButtons.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonButtons, selector: "ion-buttons", inputs: { collapse: "collapse" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonButtons = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['collapse']
        })
    ], exports.IonButtons);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonButtons, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-buttons',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['collapse']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCard = /** @class */ (function () {
        function IonCard(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCard;
    }());
    /** @nocollapse */ exports.IonCard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCard, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCard.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCard, selector: "ion-card", inputs: { button: "button", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", target: "target", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCard = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'target', 'type']
        })
    ], exports.IonCard);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCard, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-card',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'target', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCardContent = /** @class */ (function () {
        function IonCardContent(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCardContent;
    }());
    /** @nocollapse */ exports.IonCardContent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardContent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCardContent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCardContent, selector: "ion-card-content", inputs: { mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCardContent = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['mode']
        })
    ], exports.IonCardContent);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardContent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-card-content',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCardHeader = /** @class */ (function () {
        function IonCardHeader(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCardHeader;
    }());
    /** @nocollapse */ exports.IonCardHeader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardHeader, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCardHeader.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCardHeader, selector: "ion-card-header", inputs: { color: "color", mode: "mode", translucent: "translucent" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCardHeader = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode', 'translucent']
        })
    ], exports.IonCardHeader);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardHeader, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-card-header',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode', 'translucent']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCardSubtitle = /** @class */ (function () {
        function IonCardSubtitle(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCardSubtitle;
    }());
    /** @nocollapse */ exports.IonCardSubtitle.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardSubtitle, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCardSubtitle.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCardSubtitle, selector: "ion-card-subtitle", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCardSubtitle = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonCardSubtitle);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardSubtitle, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-card-subtitle',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCardTitle = /** @class */ (function () {
        function IonCardTitle(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCardTitle;
    }());
    /** @nocollapse */ exports.IonCardTitle.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardTitle, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCardTitle.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCardTitle, selector: "ion-card-title", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCardTitle = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonCardTitle);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCardTitle, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-card-title',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCheckbox = /** @class */ (function () {
        function IonCheckbox(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
        }
        return IonCheckbox;
    }());
    /** @nocollapse */ exports.IonCheckbox.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCheckbox, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCheckbox.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCheckbox, selector: "ion-checkbox", inputs: { checked: "checked", color: "color", disabled: "disabled", indeterminate: "indeterminate", mode: "mode", name: "name", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCheckbox = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']
        })
    ], exports.IonCheckbox);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCheckbox, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-checkbox',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonChip = /** @class */ (function () {
        function IonChip(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonChip;
    }());
    /** @nocollapse */ exports.IonChip.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonChip, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonChip.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonChip, selector: "ion-chip", inputs: { color: "color", disabled: "disabled", mode: "mode", outline: "outline" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonChip = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'disabled', 'mode', 'outline']
        })
    ], exports.IonChip);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonChip, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-chip',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'disabled', 'mode', 'outline']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonCol = /** @class */ (function () {
        function IonCol(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonCol;
    }());
    /** @nocollapse */ exports.IonCol.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCol, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonCol.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonCol, selector: "ion-col", inputs: { offset: "offset", offsetLg: "offsetLg", offsetMd: "offsetMd", offsetSm: "offsetSm", offsetXl: "offsetXl", offsetXs: "offsetXs", pull: "pull", pullLg: "pullLg", pullMd: "pullMd", pullSm: "pullSm", pullXl: "pullXl", pullXs: "pullXs", push: "push", pushLg: "pushLg", pushMd: "pushMd", pushSm: "pushSm", pushXl: "pushXl", pushXs: "pushXs", size: "size", sizeLg: "sizeLg", sizeMd: "sizeMd", sizeSm: "sizeSm", sizeXl: "sizeXl", sizeXs: "sizeXs" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonCol = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']
        })
    ], exports.IonCol);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonCol, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-col',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonContent = /** @class */ (function () {
        function IonContent(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);
        }
        return IonContent;
    }());
    /** @nocollapse */ exports.IonContent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonContent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonContent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonContent, selector: "ion-content", inputs: { color: "color", forceOverscroll: "forceOverscroll", fullscreen: "fullscreen", scrollEvents: "scrollEvents", scrollX: "scrollX", scrollY: "scrollY" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonContent = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY'],
            methods: ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']
        })
    ], exports.IonContent);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonContent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-content',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonDatetime = /** @class */ (function () {
        function IonDatetime(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);
        }
        return IonDatetime;
    }());
    /** @nocollapse */ exports.IonDatetime.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonDatetime, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonDatetime.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonDatetime, selector: "ion-datetime", inputs: { cancelText: "cancelText", clearText: "clearText", color: "color", dayValues: "dayValues", disabled: "disabled", doneText: "doneText", firstDayOfWeek: "firstDayOfWeek", hourCycle: "hourCycle", hourValues: "hourValues", isDateEnabled: "isDateEnabled", locale: "locale", max: "max", min: "min", minuteValues: "minuteValues", mode: "mode", monthValues: "monthValues", name: "name", presentation: "presentation", readonly: "readonly", showClearButton: "showClearButton", showDefaultButtons: "showDefaultButtons", showDefaultTimeLabel: "showDefaultTimeLabel", showDefaultTitle: "showDefaultTitle", size: "size", value: "value", yearValues: "yearValues" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonDatetime = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['cancelText', 'clearText', 'color', 'dayValues', 'disabled', 'doneText', 'firstDayOfWeek', 'hourCycle', 'hourValues', 'isDateEnabled', 'locale', 'max', 'min', 'minuteValues', 'mode', 'monthValues', 'name', 'presentation', 'readonly', 'showClearButton', 'showDefaultButtons', 'showDefaultTimeLabel', 'showDefaultTitle', 'size', 'value', 'yearValues'],
            methods: ['confirm', 'reset', 'cancel']
        })
    ], exports.IonDatetime);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonDatetime, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-datetime',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['cancelText', 'clearText', 'color', 'dayValues', 'disabled', 'doneText', 'firstDayOfWeek', 'hourCycle', 'hourValues', 'isDateEnabled', 'locale', 'max', 'min', 'minuteValues', 'mode', 'monthValues', 'name', 'presentation', 'readonly', 'showClearButton', 'showDefaultButtons', 'showDefaultTimeLabel', 'showDefaultTitle', 'size', 'value', 'yearValues']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonFab = /** @class */ (function () {
        function IonFab(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonFab;
    }());
    /** @nocollapse */ exports.IonFab.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFab, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonFab.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonFab, selector: "ion-fab", inputs: { activated: "activated", edge: "edge", horizontal: "horizontal", vertical: "vertical" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonFab = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['activated', 'edge', 'horizontal', 'vertical'],
            methods: ['close']
        })
    ], exports.IonFab);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFab, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-fab',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['activated', 'edge', 'horizontal', 'vertical']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonFabButton = /** @class */ (function () {
        function IonFabButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
        }
        return IonFabButton;
    }());
    /** @nocollapse */ exports.IonFabButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFabButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonFabButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonFabButton, selector: "ion-fab-button", inputs: { activated: "activated", closeIcon: "closeIcon", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", show: "show", size: "size", target: "target", translucent: "translucent", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonFabButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['activated', 'closeIcon', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']
        })
    ], exports.IonFabButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFabButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-fab-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['activated', 'closeIcon', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonFabList = /** @class */ (function () {
        function IonFabList(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonFabList;
    }());
    /** @nocollapse */ exports.IonFabList.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFabList, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonFabList.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonFabList, selector: "ion-fab-list", inputs: { activated: "activated", side: "side" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonFabList = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['activated', 'side']
        })
    ], exports.IonFabList);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFabList, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-fab-list',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['activated', 'side']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonFooter = /** @class */ (function () {
        function IonFooter(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonFooter;
    }());
    /** @nocollapse */ exports.IonFooter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFooter, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonFooter.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonFooter, selector: "ion-footer", inputs: { collapse: "collapse", mode: "mode", translucent: "translucent" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonFooter = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['collapse', 'mode', 'translucent']
        })
    ], exports.IonFooter);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonFooter, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-footer',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['collapse', 'mode', 'translucent']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonGrid = /** @class */ (function () {
        function IonGrid(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonGrid;
    }());
    /** @nocollapse */ exports.IonGrid.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonGrid, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonGrid.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonGrid, selector: "ion-grid", inputs: { fixed: "fixed" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonGrid = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['fixed']
        })
    ], exports.IonGrid);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonGrid, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-grid',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['fixed']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonHeader = /** @class */ (function () {
        function IonHeader(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonHeader;
    }());
    /** @nocollapse */ exports.IonHeader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonHeader, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonHeader.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonHeader, selector: "ion-header", inputs: { collapse: "collapse", mode: "mode", translucent: "translucent" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonHeader = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['collapse', 'mode', 'translucent']
        })
    ], exports.IonHeader);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonHeader, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-header',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['collapse', 'mode', 'translucent']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonIcon = /** @class */ (function () {
        function IonIcon(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonIcon;
    }());
    /** @nocollapse */ exports.IonIcon.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonIcon, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonIcon.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonIcon, selector: "ion-icon", inputs: { color: "color", flipRtl: "flipRtl", icon: "icon", ios: "ios", lazy: "lazy", md: "md", mode: "mode", name: "name", sanitize: "sanitize", size: "size", src: "src" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonIcon = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'sanitize', 'size', 'src']
        })
    ], exports.IonIcon);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonIcon, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-icon',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'sanitize', 'size', 'src']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonImg = /** @class */ (function () {
        function IonImg(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);
        }
        return IonImg;
    }());
    /** @nocollapse */ exports.IonImg.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonImg, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonImg.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonImg, selector: "ion-img", inputs: { alt: "alt", src: "src" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonImg = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['alt', 'src']
        })
    ], exports.IonImg);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonImg, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-img',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['alt', 'src']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonInfiniteScroll = /** @class */ (function () {
        function IonInfiniteScroll(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionInfinite']);
        }
        return IonInfiniteScroll;
    }());
    /** @nocollapse */ exports.IonInfiniteScroll.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInfiniteScroll, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonInfiniteScroll.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonInfiniteScroll, selector: "ion-infinite-scroll", inputs: { disabled: "disabled", position: "position", threshold: "threshold" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonInfiniteScroll = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled', 'position', 'threshold'],
            methods: ['complete']
        })
    ], exports.IonInfiniteScroll);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInfiniteScroll, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-infinite-scroll',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled', 'position', 'threshold']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonInfiniteScrollContent = /** @class */ (function () {
        function IonInfiniteScrollContent(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonInfiniteScrollContent;
    }());
    /** @nocollapse */ exports.IonInfiniteScrollContent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInfiniteScrollContent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonInfiniteScrollContent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonInfiniteScrollContent, selector: "ion-infinite-scroll-content", inputs: { loadingSpinner: "loadingSpinner", loadingText: "loadingText" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonInfiniteScrollContent = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['loadingSpinner', 'loadingText']
        })
    ], exports.IonInfiniteScrollContent);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInfiniteScrollContent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-infinite-scroll-content',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['loadingSpinner', 'loadingText']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonInput = /** @class */ (function () {
        function IonInput(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);
        }
        return IonInput;
    }());
    /** @nocollapse */ exports.IonInput.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInput, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonInput.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonInput, selector: "ion-input", inputs: { accept: "accept", autocapitalize: "autocapitalize", autocomplete: "autocomplete", autocorrect: "autocorrect", autofocus: "autofocus", clearInput: "clearInput", clearOnEdit: "clearOnEdit", color: "color", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", max: "max", maxlength: "maxlength", min: "min", minlength: "minlength", mode: "mode", multiple: "multiple", name: "name", pattern: "pattern", placeholder: "placeholder", readonly: "readonly", required: "required", size: "size", spellcheck: "spellcheck", step: "step", type: "type", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonInput = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value'],
            methods: ['setFocus', 'getInputElement']
        })
    ], exports.IonInput);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonInput, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-input',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItem = /** @class */ (function () {
        function IonItem(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonItem;
    }());
    /** @nocollapse */ exports.IonItem.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItem, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItem.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItem, selector: "ion-item", inputs: { button: "button", color: "color", counter: "counter", counterFormatter: "counterFormatter", detail: "detail", detailIcon: "detailIcon", disabled: "disabled", download: "download", fill: "fill", href: "href", lines: "lines", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", shape: "shape", target: "target", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItem = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['button', 'color', 'counter', 'counterFormatter', 'detail', 'detailIcon', 'disabled', 'download', 'fill', 'href', 'lines', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'target', 'type']
        })
    ], exports.IonItem);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItem, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['button', 'color', 'counter', 'counterFormatter', 'detail', 'detailIcon', 'disabled', 'download', 'fill', 'href', 'lines', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'target', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItemDivider = /** @class */ (function () {
        function IonItemDivider(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonItemDivider;
    }());
    /** @nocollapse */ exports.IonItemDivider.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemDivider, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItemDivider.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItemDivider, selector: "ion-item-divider", inputs: { color: "color", mode: "mode", sticky: "sticky" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItemDivider = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode', 'sticky']
        })
    ], exports.IonItemDivider);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemDivider, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item-divider',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode', 'sticky']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItemGroup = /** @class */ (function () {
        function IonItemGroup(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonItemGroup;
    }());
    /** @nocollapse */ exports.IonItemGroup.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemGroup, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItemGroup.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItemGroup, selector: "ion-item-group", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItemGroup = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonItemGroup);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemGroup, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item-group',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItemOption = /** @class */ (function () {
        function IonItemOption(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonItemOption;
    }());
    /** @nocollapse */ exports.IonItemOption.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemOption, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItemOption.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItemOption, selector: "ion-item-option", inputs: { color: "color", disabled: "disabled", download: "download", expandable: "expandable", href: "href", mode: "mode", rel: "rel", target: "target", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItemOption = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']
        })
    ], exports.IonItemOption);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemOption, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item-option',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItemOptions = /** @class */ (function () {
        function IonItemOptions(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionSwipe']);
        }
        return IonItemOptions;
    }());
    /** @nocollapse */ exports.IonItemOptions.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemOptions, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItemOptions.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItemOptions, selector: "ion-item-options", inputs: { side: "side" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItemOptions = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['side']
        })
    ], exports.IonItemOptions);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemOptions, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item-options',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['side']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonItemSliding = /** @class */ (function () {
        function IonItemSliding(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionDrag']);
        }
        return IonItemSliding;
    }());
    /** @nocollapse */ exports.IonItemSliding.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemSliding, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonItemSliding.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonItemSliding, selector: "ion-item-sliding", inputs: { disabled: "disabled" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonItemSliding = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled'],
            methods: ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']
        })
    ], exports.IonItemSliding);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonItemSliding, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-item-sliding',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonLabel = /** @class */ (function () {
        function IonLabel(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonLabel;
    }());
    /** @nocollapse */ exports.IonLabel.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonLabel, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonLabel.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonLabel, selector: "ion-label", inputs: { color: "color", mode: "mode", position: "position" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonLabel = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode', 'position']
        })
    ], exports.IonLabel);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonLabel, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-label',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode', 'position']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonList = /** @class */ (function () {
        function IonList(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonList;
    }());
    /** @nocollapse */ exports.IonList.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonList, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonList.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonList, selector: "ion-list", inputs: { inset: "inset", lines: "lines", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonList = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['inset', 'lines', 'mode'],
            methods: ['closeSlidingItems']
        })
    ], exports.IonList);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonList, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-list',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['inset', 'lines', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonListHeader = /** @class */ (function () {
        function IonListHeader(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonListHeader;
    }());
    /** @nocollapse */ exports.IonListHeader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonListHeader, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonListHeader.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonListHeader, selector: "ion-list-header", inputs: { color: "color", lines: "lines", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonListHeader = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'lines', 'mode']
        })
    ], exports.IonListHeader);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonListHeader, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-list-header',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'lines', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonMenu = /** @class */ (function () {
        function IonMenu(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);
        }
        return IonMenu;
    }());
    /** @nocollapse */ exports.IonMenu.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenu, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonMenu.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonMenu, selector: "ion-menu", inputs: { contentId: "contentId", disabled: "disabled", maxEdgeStart: "maxEdgeStart", menuId: "menuId", side: "side", swipeGesture: "swipeGesture", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonMenu = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type'],
            methods: ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']
        })
    ], exports.IonMenu);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenu, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-menu',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonMenuButton = /** @class */ (function () {
        function IonMenuButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonMenuButton;
    }());
    /** @nocollapse */ exports.IonMenuButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenuButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonMenuButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonMenuButton, selector: "ion-menu-button", inputs: { autoHide: "autoHide", color: "color", disabled: "disabled", menu: "menu", mode: "mode", type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonMenuButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['autoHide', 'color', 'disabled', 'menu', 'mode', 'type']
        })
    ], exports.IonMenuButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenuButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-menu-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['autoHide', 'color', 'disabled', 'menu', 'mode', 'type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonMenuToggle = /** @class */ (function () {
        function IonMenuToggle(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonMenuToggle;
    }());
    /** @nocollapse */ exports.IonMenuToggle.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenuToggle, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonMenuToggle.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonMenuToggle, selector: "ion-menu-toggle", inputs: { autoHide: "autoHide", menu: "menu" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonMenuToggle = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['autoHide', 'menu']
        })
    ], exports.IonMenuToggle);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonMenuToggle, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-menu-toggle',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['autoHide', 'menu']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonNav = /** @class */ (function () {
        function IonNav(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionNavWillChange', 'ionNavDidChange']);
        }
        return IonNav;
    }());
    /** @nocollapse */ exports.IonNav.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNav, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonNav.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonNav, selector: "ion-nav", inputs: { animated: "animated", animation: "animation", root: "root", rootParams: "rootParams", swipeGesture: "swipeGesture" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonNav = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],
            methods: ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']
        })
    ], exports.IonNav);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNav, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-nav',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonNavLink = /** @class */ (function () {
        function IonNavLink(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonNavLink;
    }());
    /** @nocollapse */ exports.IonNavLink.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNavLink, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonNavLink.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonNavLink, selector: "ion-nav-link", inputs: { component: "component", componentProps: "componentProps", routerAnimation: "routerAnimation", routerDirection: "routerDirection" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonNavLink = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['component', 'componentProps', 'routerAnimation', 'routerDirection']
        })
    ], exports.IonNavLink);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNavLink, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-nav-link',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['component', 'componentProps', 'routerAnimation', 'routerDirection']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonNote = /** @class */ (function () {
        function IonNote(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonNote;
    }());
    /** @nocollapse */ exports.IonNote.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNote, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonNote.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonNote, selector: "ion-note", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonNote = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonNote);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonNote, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-note',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonProgressBar = /** @class */ (function () {
        function IonProgressBar(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonProgressBar;
    }());
    /** @nocollapse */ exports.IonProgressBar.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonProgressBar, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonProgressBar.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonProgressBar, selector: "ion-progress-bar", inputs: { buffer: "buffer", color: "color", mode: "mode", reversed: "reversed", type: "type", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonProgressBar = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value']
        })
    ], exports.IonProgressBar);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonProgressBar, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-progress-bar',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRadio = /** @class */ (function () {
        function IonRadio(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
        }
        return IonRadio;
    }());
    /** @nocollapse */ exports.IonRadio.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRadio, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRadio.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRadio, selector: "ion-radio", inputs: { color: "color", disabled: "disabled", mode: "mode", name: "name", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRadio = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'disabled', 'mode', 'name', 'value']
        })
    ], exports.IonRadio);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRadio, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-radio',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'disabled', 'mode', 'name', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRadioGroup = /** @class */ (function () {
        function IonRadioGroup(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange']);
        }
        return IonRadioGroup;
    }());
    /** @nocollapse */ exports.IonRadioGroup.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRadioGroup, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRadioGroup.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRadioGroup, selector: "ion-radio-group", inputs: { allowEmptySelection: "allowEmptySelection", name: "name", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRadioGroup = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['allowEmptySelection', 'name', 'value']
        })
    ], exports.IonRadioGroup);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRadioGroup, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-radio-group',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['allowEmptySelection', 'name', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRange = /** @class */ (function () {
        function IonRange(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur', 'ionKnobMoveStart', 'ionKnobMoveEnd']);
        }
        return IonRange;
    }());
    /** @nocollapse */ exports.IonRange.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRange, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRange.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRange, selector: "ion-range", inputs: { color: "color", debounce: "debounce", disabled: "disabled", dualKnobs: "dualKnobs", max: "max", min: "min", mode: "mode", name: "name", pin: "pin", pinFormatter: "pinFormatter", snaps: "snaps", step: "step", ticks: "ticks", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRange = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'pinFormatter', 'snaps', 'step', 'ticks', 'value']
        })
    ], exports.IonRange);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRange, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-range',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'pinFormatter', 'snaps', 'step', 'ticks', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRefresher = /** @class */ (function () {
        function IonRefresher(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);
        }
        return IonRefresher;
    }());
    /** @nocollapse */ exports.IonRefresher.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRefresher, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRefresher.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRefresher, selector: "ion-refresher", inputs: { closeDuration: "closeDuration", disabled: "disabled", pullFactor: "pullFactor", pullMax: "pullMax", pullMin: "pullMin", snapbackDuration: "snapbackDuration" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRefresher = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration'],
            methods: ['complete', 'cancel', 'getProgress']
        })
    ], exports.IonRefresher);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRefresher, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-refresher',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRefresherContent = /** @class */ (function () {
        function IonRefresherContent(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonRefresherContent;
    }());
    /** @nocollapse */ exports.IonRefresherContent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRefresherContent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRefresherContent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRefresherContent, selector: "ion-refresher-content", inputs: { pullingIcon: "pullingIcon", pullingText: "pullingText", refreshingSpinner: "refreshingSpinner", refreshingText: "refreshingText" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRefresherContent = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']
        })
    ], exports.IonRefresherContent);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRefresherContent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-refresher-content',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonReorder = /** @class */ (function () {
        function IonReorder(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonReorder;
    }());
    /** @nocollapse */ exports.IonReorder.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonReorder, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonReorder.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonReorder, selector: "ion-reorder", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonReorder = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonReorder);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonReorder, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-reorder',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonReorderGroup = /** @class */ (function () {
        function IonReorderGroup(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionItemReorder']);
        }
        return IonReorderGroup;
    }());
    /** @nocollapse */ exports.IonReorderGroup.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonReorderGroup, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonReorderGroup.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonReorderGroup, selector: "ion-reorder-group", inputs: { disabled: "disabled" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonReorderGroup = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled'],
            methods: ['complete']
        })
    ], exports.IonReorderGroup);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonReorderGroup, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-reorder-group',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRippleEffect = /** @class */ (function () {
        function IonRippleEffect(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonRippleEffect;
    }());
    /** @nocollapse */ exports.IonRippleEffect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRippleEffect, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRippleEffect.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRippleEffect, selector: "ion-ripple-effect", inputs: { type: "type" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRippleEffect = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['type'],
            methods: ['addRipple']
        })
    ], exports.IonRippleEffect);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRippleEffect, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-ripple-effect',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['type']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonRow = /** @class */ (function () {
        function IonRow(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonRow;
    }());
    /** @nocollapse */ exports.IonRow.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRow, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonRow.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonRow, selector: "ion-row", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonRow = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonRow);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonRow, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-row',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSearchbar = /** @class */ (function () {
        function IonSearchbar(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);
        }
        return IonSearchbar;
    }());
    /** @nocollapse */ exports.IonSearchbar.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSearchbar, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSearchbar.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSearchbar, selector: "ion-searchbar", inputs: { animated: "animated", autocomplete: "autocomplete", autocorrect: "autocorrect", cancelButtonIcon: "cancelButtonIcon", cancelButtonText: "cancelButtonText", clearIcon: "clearIcon", color: "color", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", mode: "mode", placeholder: "placeholder", searchIcon: "searchIcon", showCancelButton: "showCancelButton", showClearButton: "showClearButton", spellcheck: "spellcheck", type: "type", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSearchbar = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'showClearButton', 'spellcheck', 'type', 'value'],
            methods: ['setFocus', 'getInputElement']
        })
    ], exports.IonSearchbar);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSearchbar, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-searchbar',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'showClearButton', 'spellcheck', 'type', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSegment = /** @class */ (function () {
        function IonSegment(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange']);
        }
        return IonSegment;
    }());
    /** @nocollapse */ exports.IonSegment.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSegment, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSegment.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSegment, selector: "ion-segment", inputs: { color: "color", disabled: "disabled", mode: "mode", scrollable: "scrollable", selectOnFocus: "selectOnFocus", swipeGesture: "swipeGesture", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSegment = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'disabled', 'mode', 'scrollable', 'selectOnFocus', 'swipeGesture', 'value']
        })
    ], exports.IonSegment);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSegment, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-segment',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'disabled', 'mode', 'scrollable', 'selectOnFocus', 'swipeGesture', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSegmentButton = /** @class */ (function () {
        function IonSegmentButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonSegmentButton;
    }());
    /** @nocollapse */ exports.IonSegmentButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSegmentButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSegmentButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSegmentButton, selector: "ion-segment-button", inputs: { disabled: "disabled", layout: "layout", mode: "mode", type: "type", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSegmentButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled', 'layout', 'mode', 'type', 'value']
        })
    ], exports.IonSegmentButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSegmentButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-segment-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled', 'layout', 'mode', 'type', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSelect = /** @class */ (function () {
        function IonSelect(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur']);
        }
        return IonSelect;
    }());
    /** @nocollapse */ exports.IonSelect.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSelect, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSelect.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSelect, selector: "ion-select", inputs: { cancelText: "cancelText", compareWith: "compareWith", disabled: "disabled", interface: "interface", interfaceOptions: "interfaceOptions", mode: "mode", multiple: "multiple", name: "name", okText: "okText", placeholder: "placeholder", selectedText: "selectedText", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSelect = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value'],
            methods: ['open']
        })
    ], exports.IonSelect);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSelect, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-select',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSelectOption = /** @class */ (function () {
        function IonSelectOption(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonSelectOption;
    }());
    /** @nocollapse */ exports.IonSelectOption.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSelectOption, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSelectOption.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSelectOption, selector: "ion-select-option", inputs: { disabled: "disabled", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSelectOption = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled', 'value']
        })
    ], exports.IonSelectOption);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSelectOption, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-select-option',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSkeletonText = /** @class */ (function () {
        function IonSkeletonText(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonSkeletonText;
    }());
    /** @nocollapse */ exports.IonSkeletonText.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSkeletonText, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSkeletonText.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSkeletonText, selector: "ion-skeleton-text", inputs: { animated: "animated" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSkeletonText = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['animated']
        })
    ], exports.IonSkeletonText);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSkeletonText, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-skeleton-text',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['animated']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSlide = /** @class */ (function () {
        function IonSlide(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonSlide;
    }());
    /** @nocollapse */ exports.IonSlide.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSlide, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSlide.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSlide, selector: "ion-slide", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSlide = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonSlide);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSlide, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-slide',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSlides = /** @class */ (function () {
        function IonSlides(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);
        }
        return IonSlides;
    }());
    /** @nocollapse */ exports.IonSlides.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSlides, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSlides.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSlides, selector: "ion-slides", inputs: { mode: "mode", options: "options", pager: "pager", scrollbar: "scrollbar" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSlides = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['mode', 'options', 'pager', 'scrollbar'],
            methods: ['update', 'updateAutoHeight', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes', 'getSwiper']
        })
    ], exports.IonSlides);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSlides, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-slides',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['mode', 'options', 'pager', 'scrollbar']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSpinner = /** @class */ (function () {
        function IonSpinner(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonSpinner;
    }());
    /** @nocollapse */ exports.IonSpinner.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSpinner, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSpinner.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSpinner, selector: "ion-spinner", inputs: { color: "color", duration: "duration", name: "name", paused: "paused" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSpinner = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'duration', 'name', 'paused']
        })
    ], exports.IonSpinner);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSpinner, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-spinner',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'duration', 'name', 'paused']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonSplitPane = /** @class */ (function () {
        function IonSplitPane(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionSplitPaneVisible']);
        }
        return IonSplitPane;
    }());
    /** @nocollapse */ exports.IonSplitPane.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSplitPane, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonSplitPane.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonSplitPane, selector: "ion-split-pane", inputs: { contentId: "contentId", disabled: "disabled", when: "when" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonSplitPane = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['contentId', 'disabled', 'when']
        })
    ], exports.IonSplitPane);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonSplitPane, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-split-pane',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['contentId', 'disabled', 'when']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonTabBar = /** @class */ (function () {
        function IonTabBar(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonTabBar;
    }());
    /** @nocollapse */ exports.IonTabBar.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTabBar, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonTabBar.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonTabBar, selector: "ion-tab-bar", inputs: { color: "color", mode: "mode", selectedTab: "selectedTab", translucent: "translucent" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonTabBar = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode', 'selectedTab', 'translucent']
        })
    ], exports.IonTabBar);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTabBar, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-tab-bar',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode', 'selectedTab', 'translucent']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonTabButton = /** @class */ (function () {
        function IonTabButton(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonTabButton;
    }());
    /** @nocollapse */ exports.IonTabButton.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTabButton, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonTabButton.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonTabButton, selector: "ion-tab-button", inputs: { disabled: "disabled", download: "download", href: "href", layout: "layout", mode: "mode", rel: "rel", selected: "selected", tab: "tab", target: "target" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonTabButton = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']
        })
    ], exports.IonTabButton);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTabButton, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-tab-button',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonText = /** @class */ (function () {
        function IonText(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonText;
    }());
    /** @nocollapse */ exports.IonText.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonText, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonText.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonText, selector: "ion-text", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonText = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonText);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonText, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-text',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonTextarea = /** @class */ (function () {
        function IonTextarea(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);
        }
        return IonTextarea;
    }());
    /** @nocollapse */ exports.IonTextarea.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTextarea, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonTextarea.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonTextarea, selector: "ion-textarea", inputs: { autoGrow: "autoGrow", autocapitalize: "autocapitalize", autofocus: "autofocus", clearOnEdit: "clearOnEdit", color: "color", cols: "cols", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", maxlength: "maxlength", minlength: "minlength", mode: "mode", name: "name", placeholder: "placeholder", readonly: "readonly", required: "required", rows: "rows", spellcheck: "spellcheck", value: "value", wrap: "wrap" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonTextarea = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap'],
            methods: ['setFocus', 'getInputElement']
        })
    ], exports.IonTextarea);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTextarea, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-textarea',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonThumbnail = /** @class */ (function () {
        function IonThumbnail(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonThumbnail;
    }());
    /** @nocollapse */ exports.IonThumbnail.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonThumbnail, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonThumbnail.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonThumbnail, selector: "ion-thumbnail", ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonThumbnail = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined
        })
    ], exports.IonThumbnail);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonThumbnail, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-thumbnail',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonTitle = /** @class */ (function () {
        function IonTitle(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonTitle;
    }());
    /** @nocollapse */ exports.IonTitle.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTitle, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonTitle.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonTitle, selector: "ion-title", inputs: { color: "color", size: "size" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonTitle = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'size']
        })
    ], exports.IonTitle);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonTitle, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-title',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'size']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonToggle = /** @class */ (function () {
        function IonToggle(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
            proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
        }
        return IonToggle;
    }());
    /** @nocollapse */ exports.IonToggle.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonToggle, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonToggle.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonToggle, selector: "ion-toggle", inputs: { checked: "checked", color: "color", disabled: "disabled", mode: "mode", name: "name", value: "value" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonToggle = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value']
        })
    ], exports.IonToggle);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonToggle, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-toggle',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });
    exports.IonToolbar = /** @class */ (function () {
        function IonToolbar(c, r, z) {
            this.z = z;
            c.detach();
            this.el = r.nativeElement;
        }
        return IonToolbar;
    }());
    /** @nocollapse */ exports.IonToolbar.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonToolbar, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonToolbar.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonToolbar, selector: "ion-toolbar", inputs: { color: "color", mode: "mode" }, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonToolbar = __decorate([
        ProxyCmp({
            defineCustomElementFn: undefined,
            inputs: ['color', 'mode']
        })
    ], exports.IonToolbar);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonToolbar, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-toolbar',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['color', 'mode']
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; } });

    /**
     * @description
     * NavParams are an object that exists on a page and can contain data for that particular view.
     * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
     * option with a simple `get` method.
     *
     * @usage
     * ```ts
     * import { NavParams } from '@ionic/angular';
     *
     * export class MyClass{
     *
     *  constructor(navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    navParams.get('userParams');
     *  }
     *
     * }
     * ```
     */
    var NavParams = /** @class */ (function () {
        function NavParams(data) {
            if (data === void 0) { data = {}; }
            this.data = data;
        }
        /**
         * Get the value of a nav-parameter for the current view
         *
         * ```ts
         * import { NavParams } from 'ionic-angular';
         *
         * export class MyClass{
         *  constructor(public navParams: NavParams){
         *    // userParams is an object we have in our nav-parameters
         *    this.navParams.get('userParams');
         *  }
         * }
         * ```
         *
         * @param param Which param you want to look up
         */
        NavParams.prototype.get = function (param) {
            return this.data[param];
        };
        return NavParams;
    }());

    var AngularDelegate = /** @class */ (function () {
        function AngularDelegate(zone, appRef) {
            this.zone = zone;
            this.appRef = appRef;
        }
        AngularDelegate.prototype.create = function (resolverOrInjector, injector, location) {
            return new AngularFrameworkDelegate(resolverOrInjector, injector, location, this.appRef, this.zone);
        };
        return AngularDelegate;
    }());
    /** @nocollapse */ AngularDelegate.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AngularDelegate, deps: [{ token: i0__namespace.NgZone }, { token: i0__namespace.ApplicationRef }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ AngularDelegate.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AngularDelegate });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AngularDelegate, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }, { type: i0__namespace.ApplicationRef }]; } });
    var AngularFrameworkDelegate = /** @class */ (function () {
        function AngularFrameworkDelegate(resolverOrInjector, injector, location, appRef, zone) {
            this.resolverOrInjector = resolverOrInjector;
            this.injector = injector;
            this.location = location;
            this.appRef = appRef;
            this.zone = zone;
            this.elRefMap = new WeakMap();
            this.elEventsMap = new WeakMap();
        }
        AngularFrameworkDelegate.prototype.attachViewToDom = function (container, component, params, cssClasses) {
            var _this = this;
            return this.zone.run(function () {
                return new Promise(function (resolve) {
                    var el = attachView(_this.zone, _this.resolverOrInjector, _this.injector, _this.location, _this.appRef, _this.elRefMap, _this.elEventsMap, container, component, params, cssClasses);
                    resolve(el);
                });
            });
        };
        AngularFrameworkDelegate.prototype.removeViewFromDom = function (_container, component) {
            var _this = this;
            return this.zone.run(function () {
                return new Promise(function (resolve) {
                    var componentRef = _this.elRefMap.get(component);
                    if (componentRef) {
                        componentRef.destroy();
                        _this.elRefMap.delete(component);
                        var unbindEvents = _this.elEventsMap.get(component);
                        if (unbindEvents) {
                            unbindEvents();
                            _this.elEventsMap.delete(component);
                        }
                    }
                    resolve();
                });
            });
        };
        return AngularFrameworkDelegate;
    }());
    var attachView = function (zone, resolverOrInjector, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {
        var e_1, _a;
        var componentRef;
        var childInjector = i0.Injector.create({
            providers: getProviders(params),
            parent: injector,
        });
        if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {
            // Angular 13 and lower
            var factory = resolverOrInjector.resolveComponentFactory(component);
            componentRef = location
                ? location.createComponent(factory, location.length, childInjector)
                : factory.create(childInjector);
        }
        else if (location) {
            // Angular 14
            var environmentInjector = resolverOrInjector;
            componentRef = location.createComponent(component, {
                index: location.indexOf,
                injector: childInjector,
                environmentInjector: environmentInjector,
            });
        }
        else {
            return null;
        }
        var instance = componentRef.instance;
        var hostElement = componentRef.location.nativeElement;
        if (params) {
            Object.assign(instance, params);
        }
        if (cssClasses) {
            try {
                for (var cssClasses_1 = __values(cssClasses), cssClasses_1_1 = cssClasses_1.next(); !cssClasses_1_1.done; cssClasses_1_1 = cssClasses_1.next()) {
                    var clazz = cssClasses_1_1.value;
                    hostElement.classList.add(clazz);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (cssClasses_1_1 && !cssClasses_1_1.done && (_a = cssClasses_1.return)) _a.call(cssClasses_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);
        container.appendChild(hostElement);
        if (!location) {
            appRef.attachView(componentRef.hostView);
        }
        componentRef.changeDetectorRef.reattach();
        elRefMap.set(hostElement, componentRef);
        elEventsMap.set(hostElement, unbindEvents);
        return hostElement;
    };
    var LIFECYCLES = [
        core.LIFECYCLE_WILL_ENTER,
        core.LIFECYCLE_DID_ENTER,
        core.LIFECYCLE_WILL_LEAVE,
        core.LIFECYCLE_DID_LEAVE,
        core.LIFECYCLE_WILL_UNLOAD,
    ];
    var bindLifecycleEvents = function (zone, instance, element) {
        return zone.run(function () {
            var unregisters = LIFECYCLES.filter(function (eventName) { return typeof instance[eventName] === 'function'; }).map(function (eventName) {
                var handler = function (ev) { return instance[eventName](ev.detail); };
                element.addEventListener(eventName, handler);
                return function () { return element.removeEventListener(eventName, handler); };
            });
            return function () { return unregisters.forEach(function (fn) { return fn(); }); };
        });
    };
    var NavParamsToken = new i0.InjectionToken('NavParamsToken');
    var getProviders = function (params) {
        return [
            {
                provide: NavParamsToken,
                useValue: params,
            },
            {
                provide: NavParams,
                useFactory: provideNavParamsInjectable,
                deps: [NavParamsToken],
            },
        ];
    };
    var provideNavParamsInjectable = function (params) {
        return new NavParams(params);
    };

    var insertView = function (views, view, direction) {
        if (direction === 'root') {
            return setRoot(views, view);
        }
        else if (direction === 'forward') {
            return setForward(views, view);
        }
        else {
            return setBack(views, view);
        }
    };
    var setRoot = function (views, view) {
        views = views.filter(function (v) { return v.stackId !== view.stackId; });
        views.push(view);
        return views;
    };
    var setForward = function (views, view) {
        var index = views.indexOf(view);
        if (index >= 0) {
            views = views.filter(function (v) { return v.stackId !== view.stackId || v.id <= view.id; });
        }
        else {
            views.push(view);
        }
        return views;
    };
    var setBack = function (views, view) {
        var index = views.indexOf(view);
        if (index >= 0) {
            return views.filter(function (v) { return v.stackId !== view.stackId || v.id <= view.id; });
        }
        else {
            return setRoot(views, view);
        }
    };
    var getUrl = function (router, activatedRoute) {
        var urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });
        return router.serializeUrl(urlTree);
    };
    var isTabSwitch = function (enteringView, leavingView) {
        if (!leavingView) {
            return true;
        }
        return enteringView.stackId !== leavingView.stackId;
    };
    var computeStackId = function (prefixUrl, url) {
        if (!prefixUrl) {
            return undefined;
        }
        var segments = toSegments(url);
        for (var i = 0; i < segments.length; i++) {
            if (i >= prefixUrl.length) {
                return segments[i];
            }
            if (segments[i] !== prefixUrl[i]) {
                return undefined;
            }
        }
        return undefined;
    };
    var toSegments = function (path) {
        return path
            .split('/')
            .map(function (s) { return s.trim(); })
            .filter(function (s) { return s !== ''; });
    };
    var destroyView = function (view) {
        if (view) {
            // TODO lifecycle event
            view.ref.destroy();
            view.unlistenEvents();
        }
    };

    var StackController = /** @class */ (function () {
        function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {
            this.containerEl = containerEl;
            this.router = router;
            this.navCtrl = navCtrl;
            this.zone = zone;
            this.location = location;
            this.views = [];
            this.skipTransition = false;
            this.nextId = 0;
            this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;
        }
        StackController.prototype.createView = function (ref, activatedRoute) {
            var _a;
            var url = getUrl(this.router, activatedRoute);
            var element = (_a = ref === null || ref === void 0 ? void 0 : ref.location) === null || _a === void 0 ? void 0 : _a.nativeElement;
            var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);
            return {
                id: this.nextId++,
                stackId: computeStackId(this.tabsPrefix, url),
                unlistenEvents: unlistenEvents,
                element: element,
                ref: ref,
                url: url,
            };
        };
        StackController.prototype.getExistingView = function (activatedRoute) {
            var activatedUrlKey = getUrl(this.router, activatedRoute);
            var view = this.views.find(function (vw) { return vw.url === activatedUrlKey; });
            if (view) {
                view.ref.changeDetectorRef.reattach();
            }
            return view;
        };
        StackController.prototype.setActive = function (enteringView) {
            var _this = this;
            var _a, _b;
            var consumeResult = this.navCtrl.consumeTransition();
            var direction = consumeResult.direction, animation = consumeResult.animation, animationBuilder = consumeResult.animationBuilder;
            var leavingView = this.activeView;
            var tabSwitch = isTabSwitch(enteringView, leavingView);
            if (tabSwitch) {
                direction = 'back';
                animation = undefined;
            }
            var viewsSnapshot = this.views.slice();
            var currentNavigation;
            var router = this.router;
            // Angular >= 7.2.0
            if (router.getCurrentNavigation) {
                currentNavigation = router.getCurrentNavigation();
                // Angular < 7.2.0
            }
            else if ((_a = router.navigations) === null || _a === void 0 ? void 0 : _a.value) {
                currentNavigation = router.navigations.value;
            }
            /**
             * If the navigation action
             * sets `replaceUrl: true`
             * then we need to make sure
             * we remove the last item
             * from our views stack
             */
            if ((_b = currentNavigation === null || currentNavigation === void 0 ? void 0 : currentNavigation.extras) === null || _b === void 0 ? void 0 : _b.replaceUrl) {
                if (this.views.length > 0) {
                    this.views.splice(-1, 1);
                }
            }
            var reused = this.views.includes(enteringView);
            var views = this.insertView(enteringView, direction);
            // Trigger change detection before transition starts
            // This will call ngOnInit() the first time too, just after the view
            // was attached to the dom, but BEFORE the transition starts
            if (!reused) {
                enteringView.ref.changeDetectorRef.detectChanges();
            }
            /**
             * If we are going back from a page that
             * was presented using a custom animation
             * we should default to using that
             * unless the developer explicitly
             * provided another animation.
             */
            var customAnimation = enteringView.animationBuilder;
            if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {
                animationBuilder = customAnimation;
            }
            /**
             * Save any custom animation so that navigating
             * back will use this custom animation by default.
             */
            if (leavingView) {
                leavingView.animationBuilder = animationBuilder;
            }
            // Wait until previous transitions finish
            return this.zone.runOutsideAngular(function () {
                return _this.wait(function () {
                    // disconnect leaving page from change detection to
                    // reduce jank during the page transition
                    if (leavingView) {
                        leavingView.ref.changeDetectorRef.detach();
                    }
                    // In case the enteringView is the same as the leavingPage we need to reattach()
                    enteringView.ref.changeDetectorRef.reattach();
                    return _this.transition(enteringView, leavingView, animation, _this.canGoBack(1), false, animationBuilder)
                        .then(function () { return cleanupAsync(enteringView, views, viewsSnapshot, _this.location, _this.zone); })
                        .then(function () { return ({
                        enteringView: enteringView,
                        direction: direction,
                        animation: animation,
                        tabSwitch: tabSwitch,
                    }); });
                });
            });
        };
        StackController.prototype.canGoBack = function (deep, stackId) {
            if (stackId === void 0) { stackId = this.getActiveStackId(); }
            return this.getStack(stackId).length > deep;
        };
        StackController.prototype.pop = function (deep, stackId) {
            var _this = this;
            if (stackId === void 0) { stackId = this.getActiveStackId(); }
            return this.zone.run(function () {
                var _a, _b;
                var views = _this.getStack(stackId);
                if (views.length <= deep) {
                    return Promise.resolve(false);
                }
                var view = views[views.length - deep - 1];
                var url = view.url;
                var viewSavedData = view.savedData;
                if (viewSavedData) {
                    var primaryOutlet = viewSavedData.get('primary');
                    if ((_b = (_a = primaryOutlet === null || primaryOutlet === void 0 ? void 0 : primaryOutlet.route) === null || _a === void 0 ? void 0 : _a._routerState) === null || _b === void 0 ? void 0 : _b.snapshot.url) {
                        url = primaryOutlet.route._routerState.snapshot.url;
                    }
                }
                var animationBuilder = _this.navCtrl.consumeTransition().animationBuilder;
                return _this.navCtrl.navigateBack(url, Object.assign(Object.assign({}, view.savedExtras), { animation: animationBuilder })).then(function () { return true; });
            });
        };
        StackController.prototype.startBackTransition = function () {
            var _this = this;
            var leavingView = this.activeView;
            if (leavingView) {
                var views = this.getStack(leavingView.stackId);
                var enteringView_1 = views[views.length - 2];
                var customAnimation_1 = enteringView_1.animationBuilder;
                return this.wait(function () {
                    return _this.transition(enteringView_1, // entering view
                    leavingView, // leaving view
                    'back', _this.canGoBack(2), true, customAnimation_1);
                });
            }
            return Promise.resolve();
        };
        StackController.prototype.endBackTransition = function (shouldComplete) {
            if (shouldComplete) {
                this.skipTransition = true;
                this.pop(1);
            }
            else if (this.activeView) {
                cleanup(this.activeView, this.views, this.views, this.location, this.zone);
            }
        };
        StackController.prototype.getLastUrl = function (stackId) {
            var views = this.getStack(stackId);
            return views.length > 0 ? views[views.length - 1] : undefined;
        };
        /**
         * @internal
         */
        StackController.prototype.getRootUrl = function (stackId) {
            var views = this.getStack(stackId);
            return views.length > 0 ? views[0] : undefined;
        };
        StackController.prototype.getActiveStackId = function () {
            return this.activeView ? this.activeView.stackId : undefined;
        };
        StackController.prototype.hasRunningTask = function () {
            return this.runningTask !== undefined;
        };
        StackController.prototype.destroy = function () {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.containerEl = undefined;
            this.views.forEach(destroyView);
            this.activeView = undefined;
            this.views = [];
        };
        StackController.prototype.getStack = function (stackId) {
            return this.views.filter(function (v) { return v.stackId === stackId; });
        };
        StackController.prototype.insertView = function (enteringView, direction) {
            this.activeView = enteringView;
            this.views = insertView(this.views, enteringView, direction);
            return this.views.slice();
        };
        StackController.prototype.transition = function (enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {
            if (this.skipTransition) {
                this.skipTransition = false;
                return Promise.resolve(false);
            }
            if (leavingView === enteringView) {
                return Promise.resolve(false);
            }
            var enteringEl = enteringView ? enteringView.element : undefined;
            var leavingEl = leavingView ? leavingView.element : undefined;
            var containerEl = this.containerEl;
            if (enteringEl && enteringEl !== leavingEl) {
                enteringEl.classList.add('ion-page');
                enteringEl.classList.add('ion-page-invisible');
                if (enteringEl.parentElement !== containerEl) {
                    containerEl.appendChild(enteringEl);
                }
                if (containerEl.commit) {
                    return containerEl.commit(enteringEl, leavingEl, {
                        deepWait: true,
                        duration: direction === undefined ? 0 : undefined,
                        direction: direction,
                        showGoBack: showGoBack,
                        progressAnimation: progressAnimation,
                        animationBuilder: animationBuilder,
                    });
                }
            }
            return Promise.resolve(false);
        };
        StackController.prototype.wait = function (task) {
            return __awaiter(this, void 0, void 0, function () {
                var promise;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!(this.runningTask !== undefined)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.runningTask];
                        case 1:
                            _c.sent();
                            this.runningTask = undefined;
                            _c.label = 2;
                        case 2:
                            promise = (this.runningTask = task());
                            promise.finally(function () { return (_this.runningTask = undefined); });
                            return [2 /*return*/, promise];
                    }
                });
            });
        };
        return StackController;
    }());
    var cleanupAsync = function (activeRoute, views, viewsSnapshot, location, zone) {
        if (typeof requestAnimationFrame === 'function') {
            return new Promise(function (resolve) {
                requestAnimationFrame(function () {
                    cleanup(activeRoute, views, viewsSnapshot, location, zone);
                    resolve();
                });
            });
        }
        return Promise.resolve();
    };
    var cleanup = function (activeRoute, views, viewsSnapshot, location, zone) {
        /**
         * Re-enter the Angular zone when destroying page components. This will allow
         * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.
         */
        zone.run(function () { return viewsSnapshot.filter(function (view) { return !views.includes(view); }).forEach(destroyView); });
        views.forEach(function (view) {
            /**
             * In the event that a user navigated multiple
             * times in rapid succession, we want to make sure
             * we don't pre-emptively detach a view while
             * it is in mid-transition.
             *
             * In this instance we also do not care about query
             * params or fragments as it will be the same view regardless
             */
            var locationWithoutParams = location.path().split('?')[0];
            var locationWithoutFragment = locationWithoutParams.split('#')[0];
            if (view !== activeRoute && view.url !== locationWithoutFragment) {
                var element = view.element;
                element.setAttribute('aria-hidden', 'true');
                element.classList.add('ion-page-hidden');
                view.ref.changeDetectorRef.detach();
            }
        });
    };

    var Config = /** @class */ (function () {
        function Config() {
        }
        Config.prototype.get = function (key, fallback) {
            var c = getConfig();
            if (c) {
                return c.get(key, fallback);
            }
            return null;
        };
        Config.prototype.getBoolean = function (key, fallback) {
            var c = getConfig();
            if (c) {
                return c.getBoolean(key, fallback);
            }
            return false;
        };
        Config.prototype.getNumber = function (key, fallback) {
            var c = getConfig();
            if (c) {
                return c.getNumber(key, fallback);
            }
            return 0;
        };
        return Config;
    }());
    /** @nocollapse */ Config.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Config, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ Config.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Config, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Config, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });
    var ConfigToken = new i0.InjectionToken('USERCONFIG');
    var getConfig = function () {
        if (typeof window !== 'undefined') {
            var Ionic = window.Ionic;
            if (Ionic === null || Ionic === void 0 ? void 0 : Ionic.config) {
                return Ionic.config;
            }
        }
        return null;
    };

    var Platform = /** @class */ (function () {
        function Platform(doc, zone) {
            var _this = this;
            this.doc = doc;
            /**
             * @hidden
             */
            this.backButton = new rxjs.Subject();
            /**
             * The keyboardDidShow event emits when the
             * on-screen keyboard is presented.
             */
            this.keyboardDidShow = new rxjs.Subject();
            /**
             * The keyboardDidHide event emits when the
             * on-screen keyboard is hidden.
             */
            this.keyboardDidHide = new rxjs.Subject();
            /**
             * The pause event emits when the native platform puts the application
             * into the background, typically when the user switches to a different
             * application. This event would emit when a Cordova app is put into
             * the background, however, it would not fire on a standard web browser.
             */
            this.pause = new rxjs.Subject();
            /**
             * The resume event emits when the native platform pulls the application
             * out from the background. This event would emit when a Cordova app comes
             * out from the background, however, it would not fire on a standard web browser.
             */
            this.resume = new rxjs.Subject();
            /**
             * The resize event emits when the browser window has changed dimensions. This
             * could be from a browser window being physically resized, or from a device
             * changing orientation.
             */
            this.resize = new rxjs.Subject();
            zone.run(function () {
                var _a;
                _this.win = doc.defaultView;
                _this.backButton.subscribeWithPriority = function (priority, callback) {
                    return this.subscribe(function (ev) {
                        return ev.register(priority, function (processNextHandler) { return zone.run(function () { return callback(processNextHandler); }); });
                    });
                };
                proxyEvent(_this.pause, doc, 'pause');
                proxyEvent(_this.resume, doc, 'resume');
                proxyEvent(_this.backButton, doc, 'ionBackButton');
                proxyEvent(_this.resize, _this.win, 'resize');
                proxyEvent(_this.keyboardDidShow, _this.win, 'ionKeyboardDidShow');
                proxyEvent(_this.keyboardDidHide, _this.win, 'ionKeyboardDidHide');
                var readyResolve;
                _this._readyPromise = new Promise(function (res) {
                    readyResolve = res;
                });
                if ((_a = _this.win) === null || _a === void 0 ? void 0 : _a['cordova']) {
                    doc.addEventListener('deviceready', function () {
                        readyResolve('cordova');
                    }, { once: true });
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    readyResolve('dom');
                }
            });
        }
        /**
         * @returns returns true/false based on platform.
         * @description
         * Depending on the platform the user is on, `is(platformName)` will
         * return `true` or `false`. Note that the same app can return `true`
         * for more than one platform name. For example, an app running from
         * an iPad would return `true` for the platform names: `mobile`,
         * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
         * from Cordova then `cordova` would be true, and if it was running
         * from a web browser on the iPad then `mobileweb` would be `true`.
         *
         * ```
         * import { Platform } from 'ionic-angular';
         *
         * @Component({...})
         * export MyPage {
         *   constructor(public platform: Platform) {
         *     if (this.platform.is('ios')) {
         *       // This will only print when on iOS
         *       console.log('I am an iOS device!');
         *     }
         *   }
         * }
         * ```
         *
         * | Platform Name   | Description                        |
         * |-----------------|------------------------------------|
         * | android         | on a device running Android.       |
         * | capacitor       | on a device running Capacitor.     |
         * | cordova         | on a device running Cordova.       |
         * | ios             | on a device running iOS.           |
         * | ipad            | on an iPad device.                 |
         * | iphone          | on an iPhone device.               |
         * | phablet         | on a phablet device.               |
         * | tablet          | on a tablet device.                |
         * | electron        | in Electron on a desktop device.   |
         * | pwa             | as a PWA app.                      |
         * | mobile          | on a mobile device.                |
         * | mobileweb       | on a mobile device in a browser.   |
         * | desktop         | on a desktop device.               |
         * | hybrid          | is a cordova or capacitor app.     |
         *
         */
        Platform.prototype.is = function (platformName) {
            return core.isPlatform(this.win, platformName);
        };
        /**
         * @returns the array of platforms
         * @description
         * Depending on what device you are on, `platforms` can return multiple values.
         * Each possible value is a hierarchy of platforms. For example, on an iPhone,
         * it would return `mobile`, `ios`, and `iphone`.
         *
         * ```
         * import { Platform } from 'ionic-angular';
         *
         * @Component({...})
         * export MyPage {
         *   constructor(public platform: Platform) {
         *     // This will print an array of the current platforms
         *     console.log(this.platform.platforms());
         *   }
         * }
         * ```
         */
        Platform.prototype.platforms = function () {
            return core.getPlatforms(this.win);
        };
        /**
         * Returns a promise when the platform is ready and native functionality
         * can be called. If the app is running from within a web browser, then
         * the promise will resolve when the DOM is ready. When the app is running
         * from an application engine such as Cordova, then the promise will
         * resolve when Cordova triggers the `deviceready` event.
         *
         * The resolved value is the `readySource`, which states which platform
         * ready was used. For example, when Cordova is ready, the resolved ready
         * source is `cordova`. The default ready source value will be `dom`. The
         * `readySource` is useful if different logic should run depending on the
         * platform the app is running from. For example, only Cordova can execute
         * the status bar plugin, so the web should not run status bar plugin logic.
         *
         * ```
         * import { Component } from '@angular/core';
         * import { Platform } from 'ionic-angular';
         *
         * @Component({...})
         * export MyApp {
         *   constructor(public platform: Platform) {
         *     this.platform.ready().then((readySource) => {
         *       console.log('Platform ready from', readySource);
         *       // Platform now ready, execute any required native code
         *     });
         *   }
         * }
         * ```
         */
        Platform.prototype.ready = function () {
            return this._readyPromise;
        };
        Object.defineProperty(Platform.prototype, "isRTL", {
            /**
             * Returns if this app is using right-to-left language direction or not.
             * We recommend the app's `index.html` file already has the correct `dir`
             * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
             * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
             */
            get: function () {
                return this.doc.dir === 'rtl';
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get the query string parameter
         */
        Platform.prototype.getQueryParam = function (key) {
            return readQueryParam(this.win.location.href, key);
        };
        /**
         * Returns `true` if the app is in landscape mode.
         */
        Platform.prototype.isLandscape = function () {
            return !this.isPortrait();
        };
        /**
         * Returns `true` if the app is in portrait mode.
         */
        Platform.prototype.isPortrait = function () {
            var _a, _b;
            return (_b = (_a = this.win).matchMedia) === null || _b === void 0 ? void 0 : _b.call(_a, '(orientation: portrait)').matches;
        };
        Platform.prototype.testUserAgent = function (expression) {
            var nav = this.win.navigator;
            return !!((nav === null || nav === void 0 ? void 0 : nav.userAgent) && nav.userAgent.indexOf(expression) >= 0);
        };
        /**
         * Get the current url.
         */
        Platform.prototype.url = function () {
            return this.win.location.href;
        };
        /**
         * Gets the width of the platform's viewport using `window.innerWidth`.
         */
        Platform.prototype.width = function () {
            return this.win.innerWidth;
        };
        /**
         * Gets the height of the platform's viewport using `window.innerHeight`.
         */
        Platform.prototype.height = function () {
            return this.win.innerHeight;
        };
        return Platform;
    }());
    /** @nocollapse */ Platform.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Platform, deps: [{ token: i1.DOCUMENT }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ Platform.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Platform, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: Platform, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i1.DOCUMENT]
                        }] }, { type: i0__namespace.NgZone }];
        } });
    var readQueryParam = function (url, key) {
        key = key.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
        var results = regex.exec(url);
        return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
    };
    var proxyEvent = function (emitter, el, eventName) {
        if (el) {
            el.addEventListener(eventName, function (ev) {
                // ?? cordova might emit "null" events
                emitter.next(ev != null ? ev.detail : undefined);
            });
        }
    };

    var NavController = /** @class */ (function () {
        function NavController(platform, location, serializer, router) {
            var _this = this;
            this.location = location;
            this.serializer = serializer;
            this.router = router;
            this.direction = DEFAULT_DIRECTION;
            this.animated = DEFAULT_ANIMATED;
            this.guessDirection = 'forward';
            this.lastNavId = -1;
            // Subscribe to router events to detect direction
            if (router) {
                router.events.subscribe(function (ev) {
                    if (ev instanceof i3.NavigationStart) {
                        var id = ev.restoredState ? ev.restoredState.navigationId : ev.id;
                        _this.guessDirection = id < _this.lastNavId ? 'back' : 'forward';
                        _this.guessAnimation = !ev.restoredState ? _this.guessDirection : undefined;
                        _this.lastNavId = _this.guessDirection === 'forward' ? ev.id : id;
                    }
                });
            }
            // Subscribe to backButton events
            platform.backButton.subscribeWithPriority(0, function (processNextHandler) {
                _this.pop();
                processNextHandler();
            });
        }
        /**
         * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
         * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
         *
         * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
         * and that it will show a "forward" animation by default.
         *
         * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
         *
         * ```html
         * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
         * ```
         */
        NavController.prototype.navigateForward = function (url, options) {
            if (options === void 0) { options = {}; }
            this.setDirection('forward', options.animated, options.animationDirection, options.animation);
            return this.navigate(url, options);
        };
        /**
         * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
         * it's equivalent to calling:
         *
         * ```ts
         * this.navController.setDirection('back');
         * this.router.navigateByUrl(path);
         * ```
         *
         * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
         * and that it will show a "back" animation by default.
         *
         * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
         *
         * ```html
         * <a routerLink="/path/to/page" routerDirection="back">Link</a>
         * ```
         */
        NavController.prototype.navigateBack = function (url, options) {
            if (options === void 0) { options = {}; }
            this.setDirection('back', options.animated, options.animationDirection, options.animation);
            return this.navigate(url, options);
        };
        /**
         * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
         * it's equivalent to calling:
         *
         * ```ts
         * this.navController.setDirection('root');
         * this.router.navigateByUrl(path);
         * ```
         *
         * Going **root** means that all existing pages in the stack will be removed,
         * and the navigated page will become the single page in the stack.
         *
         * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
         *
         * ```html
         * <a routerLink="/path/to/page" routerDirection="root">Link</a>
         * ```
         */
        NavController.prototype.navigateRoot = function (url, options) {
            if (options === void 0) { options = {}; }
            this.setDirection('root', options.animated, options.animationDirection, options.animation);
            return this.navigate(url, options);
        };
        /**
         * Same as [Location](https://angular.io/api/common/Location)'s back() method.
         * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
         * by default.
         */
        NavController.prototype.back = function (options) {
            if (options === void 0) { options = { animated: true, animationDirection: 'back' }; }
            this.setDirection('back', options.animated, options.animationDirection, options.animation);
            return this.location.back();
        };
        /**
         * This methods goes back in the context of Ionic's stack navigation.
         *
         * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
         * This is the recommended way to go back when you are using `ion-router-outlet`.
         */
        NavController.prototype.pop = function () {
            return __awaiter(this, void 0, void 0, function () {
                var outlet;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            outlet = this.topOutlet;
                            _a.label = 1;
                        case 1:
                            if (!outlet) return [3 /*break*/, 3];
                            return [4 /*yield*/, outlet.pop()];
                        case 2:
                            if (_a.sent()) {
                                return [3 /*break*/, 3];
                            }
                            else {
                                outlet = outlet.parentOutlet;
                            }
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * This methods specifies the direction of the next navigation performed by the Angular router.
         *
         * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
         *
         * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
         */
        NavController.prototype.setDirection = function (direction, animated, animationDirection, animationBuilder) {
            this.direction = direction;
            this.animated = getAnimation(direction, animated, animationDirection);
            this.animationBuilder = animationBuilder;
        };
        /**
         * @internal
         */
        NavController.prototype.setTopOutlet = function (outlet) {
            this.topOutlet = outlet;
        };
        /**
         * @internal
         */
        NavController.prototype.consumeTransition = function () {
            var direction = 'root';
            var animation;
            var animationBuilder = this.animationBuilder;
            if (this.direction === 'auto') {
                direction = this.guessDirection;
                animation = this.guessAnimation;
            }
            else {
                animation = this.animated;
                direction = this.direction;
            }
            this.direction = DEFAULT_DIRECTION;
            this.animated = DEFAULT_ANIMATED;
            this.animationBuilder = undefined;
            return {
                direction: direction,
                animation: animation,
                animationBuilder: animationBuilder,
            };
        };
        NavController.prototype.navigate = function (url, options) {
            if (Array.isArray(url)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return this.router.navigate(url, options);
            }
            else {
                /**
                 * navigateByUrl ignores any properties that
                 * would change the url, so things like queryParams
                 * would be ignored unless we create a url tree
                 * More Info: https://github.com/angular/angular/issues/18798
                 */
                var urlTree = this.serializer.parse(url.toString());
                if (options.queryParams !== undefined) {
                    urlTree.queryParams = Object.assign({}, options.queryParams);
                }
                if (options.fragment !== undefined) {
                    urlTree.fragment = options.fragment;
                }
                /**
                 * `navigateByUrl` will still apply `NavigationExtras` properties
                 * that do not modify the url, such as `replaceUrl` which is why
                 * `options` is passed in here.
                 */
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return this.router.navigateByUrl(urlTree, options);
            }
        };
        return NavController;
    }());
    /** @nocollapse */ NavController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: NavController, deps: [{ token: Platform }, { token: i1__namespace.Location }, { token: i3__namespace.UrlSerializer }, { token: i3__namespace.Router, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ NavController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: NavController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: NavController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: Platform }, { type: i1__namespace.Location }, { type: i3__namespace.UrlSerializer }, { type: i3__namespace.Router, decorators: [{
                            type: i0.Optional
                        }] }];
        } });
    var getAnimation = function (direction, animated, animationDirection) {
        if (animated === false) {
            return undefined;
        }
        if (animationDirection !== undefined) {
            return animationDirection;
        }
        if (direction === 'forward' || direction === 'back') {
            return direction;
        }
        else if (direction === 'root' && animated === true) {
            return 'forward';
        }
        return undefined;
    };
    var DEFAULT_DIRECTION = 'auto';
    var DEFAULT_ANIMATED = undefined;

    /**
     * An `Injector` that's part of the environment injector hierarchy, which exists outside of the
     * component tree.
     *
     * @developerPreview
     */
    var EnvironmentInjector = /** @class */ (function () {
        function EnvironmentInjector() {
        }
        return EnvironmentInjector;
    }());

    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var IonRouterOutlet = /** @class */ (function () {
        function IonRouterOutlet(parentContexts, location, name, tabs, config, navCtrl, environmentInjector, componentFactoryResolver, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {
            this.parentContexts = parentContexts;
            this.location = location;
            this.config = config;
            this.navCtrl = navCtrl;
            this.environmentInjector = environmentInjector;
            this.componentFactoryResolver = componentFactoryResolver;
            this.parentOutlet = parentOutlet;
            this.activated = null;
            this.activatedView = null;
            this._activatedRoute = null;
            // Maintain map of activated route proxies for each component instance
            this.proxyMap = new WeakMap();
            // Keep the latest activated route in a subject for the proxy routes to switch map to
            this.currentActivatedRoute$ = new rxjs.BehaviorSubject(null);
            this.stackEvents = new i0.EventEmitter();
            // eslint-disable-next-line @angular-eslint/no-output-rename
            this.activateEvents = new i0.EventEmitter();
            // eslint-disable-next-line @angular-eslint/no-output-rename
            this.deactivateEvents = new i0.EventEmitter();
            this.nativeEl = elementRef.nativeElement;
            this.name = name || i3.PRIMARY_OUTLET;
            this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;
            this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);
            parentContexts.onChildOutletCreated(this.name, this);
        }
        Object.defineProperty(IonRouterOutlet.prototype, "animation", {
            set: function (animation) {
                this.nativeEl.animation = animation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IonRouterOutlet.prototype, "animated", {
            set: function (animated) {
                this.nativeEl.animated = animated;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IonRouterOutlet.prototype, "swipeGesture", {
            set: function (swipe) {
                var _this = this;
                this._swipeGesture = swipe;
                this.nativeEl.swipeHandler = swipe
                    ? {
                        canStart: function () { return _this.stackCtrl.canGoBack(1) && !_this.stackCtrl.hasRunningTask(); },
                        onStart: function () { return _this.stackCtrl.startBackTransition(); },
                        onEnd: function (shouldContinue) { return _this.stackCtrl.endBackTransition(shouldContinue); },
                    }
                    : undefined;
            },
            enumerable: false,
            configurable: true
        });
        IonRouterOutlet.prototype.ngOnDestroy = function () {
            this.stackCtrl.destroy();
        };
        IonRouterOutlet.prototype.getContext = function () {
            return this.parentContexts.getContext(this.name);
        };
        IonRouterOutlet.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.activated) {
                // If the outlet was not instantiated at the time the route got activated we need to populate
                // the outlet when it is initialized (ie inside a NgIf)
                var context = this.getContext();
                if (context === null || context === void 0 ? void 0 : context.route) {
                    this.activateWith(context.route, context.resolver || null);
                }
            }
            new Promise(function (resolve) { return core.componentOnReady(_this.nativeEl, resolve); }).then(function () {
                if (_this._swipeGesture === undefined) {
                    _this.swipeGesture = _this.config.getBoolean('swipeBackEnabled', _this.nativeEl.mode === 'ios');
                }
            });
        };
        Object.defineProperty(IonRouterOutlet.prototype, "isActivated", {
            get: function () {
                return !!this.activated;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IonRouterOutlet.prototype, "component", {
            get: function () {
                if (!this.activated) {
                    throw new Error('Outlet is not activated');
                }
                return this.activated.instance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IonRouterOutlet.prototype, "activatedRoute", {
            get: function () {
                if (!this.activated) {
                    throw new Error('Outlet is not activated');
                }
                return this._activatedRoute;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IonRouterOutlet.prototype, "activatedRouteData", {
            get: function () {
                if (this._activatedRoute) {
                    return this._activatedRoute.snapshot.data;
                }
                return {};
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         */
        IonRouterOutlet.prototype.detach = function () {
            throw new Error('incompatible reuse strategy');
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        IonRouterOutlet.prototype.attach = function (_ref, _activatedRoute) {
            throw new Error('incompatible reuse strategy');
        };
        IonRouterOutlet.prototype.deactivate = function () {
            if (this.activated) {
                if (this.activatedView) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    var context = this.getContext();
                    this.activatedView.savedData = new Map(context.children['contexts']);
                    /**
                     * Angular v11.2.10 introduced a change
                     * where this route context is cleared out when
                     * a router-outlet is deactivated, However,
                     * we need this route information in order to
                     * return a user back to the correct tab when
                     * leaving and then going back to the tab context.
                     */
                    var primaryOutlet = this.activatedView.savedData.get('primary');
                    if (primaryOutlet && context.route) {
                        primaryOutlet.route = Object.assign({}, context.route);
                    }
                    /**
                     * Ensure we are saving the NavigationExtras
                     * data otherwise it will be lost
                     */
                    this.activatedView.savedExtras = {};
                    if (context.route) {
                        var contextSnapshot = context.route.snapshot;
                        this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;
                        this.activatedView.savedExtras.fragment = contextSnapshot.fragment;
                    }
                }
                var c = this.component;
                this.activatedView = null;
                this.activated = null;
                this._activatedRoute = null;
                this.deactivateEvents.emit(c);
            }
        };
        IonRouterOutlet.prototype.activateWith = function (activatedRoute, resolverOrInjector) {
            var _this = this;
            if (this.isActivated) {
                throw new Error('Cannot activate an already activated outlet');
            }
            this._activatedRoute = activatedRoute;
            var cmpRef;
            var enteringView = this.stackCtrl.getExistingView(activatedRoute);
            if (enteringView) {
                cmpRef = this.activated = enteringView.ref;
                var saved = enteringView.savedData;
                if (saved) {
                    // self-restore
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    var context = this.getContext();
                    context.children['contexts'] = saved;
                }
                // Updated activated route proxy for this component
                this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);
            }
            else {
                var snapshot = activatedRoute._futureSnapshot;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var component = snapshot.routeConfig.component;
                var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
                // We create an activated route proxy object that will maintain future updates for this component
                // over its lifecycle in the stack.
                var component$ = new rxjs.BehaviorSubject(null);
                var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);
                var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);
                /**
                 * The resolver is not always provided and is required in < Angular 14.
                 * Fallback to the class-level provider when the resolver is not set.
                 */
                resolverOrInjector = resolverOrInjector || this.componentFactoryResolver;
                if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {
                    // Backwards compatibility for Angular 13 and lower
                    var factory = resolverOrInjector.resolveComponentFactory(component);
                    cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);
                }
                else {
                    /**
                     * Angular 14 and higher.
                     *
                     * TODO: FW-1641: Migrate once Angular 13 support is dropped.
                     *
                     * When we drop < Angular 14, we can replace the following code with:
                     * ```ts
                      const environmentInjector = resolverOrInjector ?? this.environmentInjector;
                        cmpRef = this.activated = location.createComponent(component, {
                          index: location.length,
                          injector,
                          environmentInjector,
                        });
                     * ```
                     * where `this.environmentInjector` is a provider of `EnvironmentInjector` from @angular/core.
                     */
                    var environmentInjector = resolverOrInjector !== null && resolverOrInjector !== void 0 ? resolverOrInjector : this.environmentInjector;
                    cmpRef = this.activated = this.location.createComponent(component, {
                        index: this.location.length,
                        injector: injector,
                        environmentInjector: environmentInjector,
                    });
                }
                // Once the component is created we can push it to our local subject supplied to the proxy
                component$.next(cmpRef.instance);
                // Calling `markForCheck` to make sure we will run the change detection when the
                // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
                enteringView = this.stackCtrl.createView(this.activated, activatedRoute);
                // Store references to the proxy by component
                this.proxyMap.set(cmpRef.instance, activatedRouteProxy);
                this.currentActivatedRoute$.next({ component: cmpRef.instance, activatedRoute: activatedRoute });
            }
            this.activatedView = enteringView;
            this.stackCtrl.setActive(enteringView).then(function (data) {
                _this.navCtrl.setTopOutlet(_this);
                _this.activateEvents.emit(cmpRef.instance);
                _this.stackEvents.emit(data);
            });
        };
        /**
         * Returns `true` if there are pages in the stack to go back.
         */
        IonRouterOutlet.prototype.canGoBack = function (deep, stackId) {
            if (deep === void 0) { deep = 1; }
            return this.stackCtrl.canGoBack(deep, stackId);
        };
        /**
         * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.
         */
        IonRouterOutlet.prototype.pop = function (deep, stackId) {
            if (deep === void 0) { deep = 1; }
            return this.stackCtrl.pop(deep, stackId);
        };
        /**
         * Returns the URL of the active page of each stack.
         */
        IonRouterOutlet.prototype.getLastUrl = function (stackId) {
            var active = this.stackCtrl.getLastUrl(stackId);
            return active ? active.url : undefined;
        };
        /**
         * Returns the RouteView of the active page of each stack.
         * @internal
         */
        IonRouterOutlet.prototype.getLastRouteView = function (stackId) {
            return this.stackCtrl.getLastUrl(stackId);
        };
        /**
         * Returns the root view in the tab stack.
         * @internal
         */
        IonRouterOutlet.prototype.getRootView = function (stackId) {
            return this.stackCtrl.getRootUrl(stackId);
        };
        /**
         * Returns the active stack ID. In the context of ion-tabs, it means the active tab.
         */
        IonRouterOutlet.prototype.getActiveStackId = function () {
            return this.stackCtrl.getActiveStackId();
        };
        /**
         * Since the activated route can change over the life time of a component in an ion router outlet, we create
         * a proxy so that we can update the values over time as a user navigates back to components already in the stack.
         */
        IonRouterOutlet.prototype.createActivatedRouteProxy = function (component$, activatedRoute) {
            var proxy = new i3.ActivatedRoute();
            proxy._futureSnapshot = activatedRoute._futureSnapshot;
            proxy._routerState = activatedRoute._routerState;
            proxy.snapshot = activatedRoute.snapshot;
            proxy.outlet = activatedRoute.outlet;
            proxy.component = activatedRoute.component;
            // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates
            proxy._paramMap = this.proxyObservable(component$, 'paramMap');
            proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');
            proxy.url = this.proxyObservable(component$, 'url');
            proxy.params = this.proxyObservable(component$, 'params');
            proxy.queryParams = this.proxyObservable(component$, 'queryParams');
            proxy.fragment = this.proxyObservable(component$, 'fragment');
            proxy.data = this.proxyObservable(component$, 'data');
            return proxy;
        };
        /**
         * Create a wrapped observable that will switch to the latest activated route matched by the given component
         */
        IonRouterOutlet.prototype.proxyObservable = function (component$, path) {
            var _this = this;
            return component$.pipe(
            // First wait until the component instance is pushed
            operators.filter(function (component) { return !!component; }), operators.switchMap(function (component) { return _this.currentActivatedRoute$.pipe(operators.filter(function (current) { return current !== null && current.component === component; }), operators.switchMap(function (current) { return current && current.activatedRoute[path]; }), operators.distinctUntilChanged()); }));
        };
        /**
         * Updates the activated route proxy for the given component to the new incoming router state
         */
        IonRouterOutlet.prototype.updateActivatedRouteProxy = function (component, activatedRoute) {
            var proxy = this.proxyMap.get(component);
            if (!proxy) {
                throw new Error("Could not find activated route proxy for view");
            }
            proxy._futureSnapshot = activatedRoute._futureSnapshot;
            proxy._routerState = activatedRoute._routerState;
            proxy.snapshot = activatedRoute.snapshot;
            proxy.outlet = activatedRoute.outlet;
            proxy.component = activatedRoute.component;
            this.currentActivatedRoute$.next({ component: component, activatedRoute: activatedRoute });
        };
        return IonRouterOutlet;
    }());
    /** @nocollapse */ IonRouterOutlet.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonRouterOutlet, deps: [{ token: i3__namespace.ChildrenOutletContexts }, { token: i0__namespace.ViewContainerRef }, { token: 'name', attribute: true }, { token: 'tabs', attribute: true, optional: true }, { token: Config }, { token: NavController }, { token: EnvironmentInjector, optional: true }, { token: i0__namespace.ComponentFactoryResolver, optional: true }, { token: i1__namespace.Location }, { token: i0__namespace.ElementRef }, { token: i3__namespace.Router }, { token: i0__namespace.NgZone }, { token: i3__namespace.ActivatedRoute }, { token: IonRouterOutlet, optional: true, skipSelf: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ IonRouterOutlet.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: IonRouterOutlet, selector: "ion-router-outlet", inputs: { animated: "animated", animation: "animation", swipeGesture: "swipeGesture" }, outputs: { stackEvents: "stackEvents", activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonRouterOutlet, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ion-router-outlet',
                        exportAs: 'outlet',
                        // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                        inputs: ['animated', 'animation', 'swipeGesture'],
                    }]
            }], ctorParameters: function () {
            return [{ type: i3__namespace.ChildrenOutletContexts }, { type: i0__namespace.ViewContainerRef }, { type: undefined, decorators: [{
                            type: i0.Attribute,
                            args: ['name']
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Attribute,
                            args: ['tabs']
                        }] }, { type: Config }, { type: NavController }, { type: EnvironmentInjector, decorators: [{
                            type: i0.Optional
                        }] }, { type: i0__namespace.ComponentFactoryResolver, decorators: [{
                            type: i0.Optional
                        }] }, { type: i1__namespace.Location }, { type: i0__namespace.ElementRef }, { type: i3__namespace.Router }, { type: i0__namespace.NgZone }, { type: i3__namespace.ActivatedRoute }, { type: IonRouterOutlet, decorators: [{
                            type: i0.SkipSelf
                        }, {
                            type: i0.Optional
                        }] }];
        }, propDecorators: { stackEvents: [{
                    type: i0.Output
                }], activateEvents: [{
                    type: i0.Output,
                    args: ['activate']
                }], deactivateEvents: [{
                    type: i0.Output,
                    args: ['deactivate']
                }] } });
    var OutletInjector = /** @class */ (function () {
        function OutletInjector(route, childContexts, parent) {
            this.route = route;
            this.childContexts = childContexts;
            this.parent = parent;
        }
        OutletInjector.prototype.get = function (token, notFoundValue) {
            if (token === i3.ActivatedRoute) {
                return this.route;
            }
            if (token === i3.ChildrenOutletContexts) {
                return this.childContexts;
            }
            return this.parent.get(token, notFoundValue);
        };
        return OutletInjector;
    }());

    // eslint-disable-next-line @angular-eslint/component-class-suffix
    var IonTabs = /** @class */ (function () {
        function IonTabs(navCtrl) {
            this.navCtrl = navCtrl;
            this.ionTabsWillChange = new i0.EventEmitter();
            this.ionTabsDidChange = new i0.EventEmitter();
        }
        /**
         * @internal
         */
        IonTabs.prototype.onPageSelected = function (detail) {
            var stackId = detail.enteringView.stackId;
            if (detail.tabSwitch && stackId !== undefined) {
                this.ionTabsWillChange.emit({ tab: stackId });
                if (this.tabBar) {
                    this.tabBar.selectedTab = stackId;
                }
                this.ionTabsDidChange.emit({ tab: stackId });
            }
        };
        /**
         * When a tab button is clicked, there are several scenarios:
         * 1. If the selected tab is currently active (the tab button has been clicked
         *    again), then it should go to the root view for that tab.
         *
         *   a. Get the saved root view from the router outlet. If the saved root view
         *      matches the tabRootUrl, set the route view to this view including the
         *      navigation extras.
         *   b. If the saved root view from the router outlet does
         *      not match, navigate to the tabRootUrl. No navigation extras are
         *      included.
         *
         * 2. If the current tab tab is not currently selected, get the last route
         *    view from the router outlet.
         *
         *   a. If the last route view exists, navigate to that view including any
         *      navigation extras
         *   b. If the last route view doesn't exist, then navigate
         *      to the default tabRootUrl
         */
        IonTabs.prototype.select = function (tabOrEvent) {
            var isTabString = typeof tabOrEvent === 'string';
            var tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;
            var alreadySelected = this.outlet.getActiveStackId() === tab;
            var tabRootUrl = this.outlet.tabsPrefix + "/" + tab;
            /**
             * If this is a nested tab, prevent the event
             * from bubbling otherwise the outer tabs
             * will respond to this event too, causing
             * the app to get directed to the wrong place.
             */
            if (!isTabString) {
                tabOrEvent.stopPropagation();
            }
            if (alreadySelected) {
                var activeStackId = this.outlet.getActiveStackId();
                var activeView = this.outlet.getLastRouteView(activeStackId);
                // If on root tab, do not navigate to root tab again
                if ((activeView === null || activeView === void 0 ? void 0 : activeView.url) === tabRootUrl) {
                    return;
                }
                var rootView = this.outlet.getRootView(tab);
                var navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;
                return this.navCtrl.navigateRoot(tabRootUrl, Object.assign(Object.assign({}, navigationExtras), { animated: true, animationDirection: 'back' }));
            }
            else {
                var lastRoute = this.outlet.getLastRouteView(tab);
                /**
                 * If there is a lastRoute, goto that, otherwise goto the fallback url of the
                 * selected tab
                 */
                var url = (lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.url) || tabRootUrl;
                var navigationExtras = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.savedExtras;
                return this.navCtrl.navigateRoot(url, Object.assign(Object.assign({}, navigationExtras), { animated: true, animationDirection: 'back' }));
            }
        };
        IonTabs.prototype.getSelected = function () {
            return this.outlet.getActiveStackId();
        };
        return IonTabs;
    }());
    /** @nocollapse */ IonTabs.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonTabs, deps: [{ token: NavController }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ IonTabs.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: IonTabs, selector: "ion-tabs", outputs: { ionTabsWillChange: "ionTabsWillChange", ionTabsDidChange: "ionTabsDidChange" }, host: { listeners: { "ionTabButtonClick": "select($event)" } }, queries: [{ propertyName: "tabBar", first: true, predicate: exports.IonTabBar, descendants: true }], viewQueries: [{ propertyName: "outlet", first: true, predicate: ["outlet"], descendants: true, read: IonRouterOutlet }], ngImport: i0__namespace, template: " <ng-content select=\"[slot=top]\"></ng-content>\n    <div class=\"tabs-inner\">\n      <ion-router-outlet #outlet tabs=\"true\" (stackEvents)=\"onPageSelected($event)\"></ion-router-outlet>\n    </div>\n    <ng-content></ng-content>", isInline: true, styles: ["\n      :host {\n        display: flex;\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n\n        flex-direction: column;\n\n        width: 100%;\n        height: 100%;\n\n        contain: layout size style;\n        z-index: $z-index-page-container;\n      }\n      .tabs-inner {\n        position: relative;\n\n        flex: 1;\n\n        contain: layout size style;\n      }\n    "], directives: [{ type: IonRouterOutlet, selector: "ion-router-outlet", inputs: ["animated", "animation", "swipeGesture"], outputs: ["stackEvents", "activate", "deactivate"], exportAs: ["outlet"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonTabs, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-tabs',
                        template: " <ng-content select=\"[slot=top]\"></ng-content>\n    <div class=\"tabs-inner\">\n      <ion-router-outlet #outlet tabs=\"true\" (stackEvents)=\"onPageSelected($event)\"></ion-router-outlet>\n    </div>\n    <ng-content></ng-content>",
                        styles: [
                            "\n      :host {\n        display: flex;\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n\n        flex-direction: column;\n\n        width: 100%;\n        height: 100%;\n\n        contain: layout size style;\n        z-index: $z-index-page-container;\n      }\n      .tabs-inner {\n        position: relative;\n\n        flex: 1;\n\n        contain: layout size style;\n      }\n    ",
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: NavController }]; }, propDecorators: { outlet: [{
                    type: i0.ViewChild,
                    args: ['outlet', { read: IonRouterOutlet, static: false }]
                }], tabBar: [{
                    type: i0.ContentChild,
                    args: [exports.IonTabBar, { static: false }]
                }], ionTabsWillChange: [{
                    type: i0.Output
                }], ionTabsDidChange: [{
                    type: i0.Output
                }], select: [{
                    type: i0.HostListener,
                    args: ['ionTabButtonClick', ['$event']]
                }] } });

    var IonBackButtonDelegateDirective = /** @class */ (function () {
        function IonBackButtonDelegateDirective(routerOutlet, navCtrl, config) {
            this.routerOutlet = routerOutlet;
            this.navCtrl = navCtrl;
            this.config = config;
        }
        /**
         * @internal
         */
        IonBackButtonDelegateDirective.prototype.onClick = function (ev) {
            var _a;
            var defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');
            if ((_a = this.routerOutlet) === null || _a === void 0 ? void 0 : _a.canGoBack()) {
                this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);
                this.routerOutlet.pop();
                ev.preventDefault();
            }
            else if (defaultHref != null) {
                this.navCtrl.navigateBack(defaultHref, { animation: this.routerAnimation });
                ev.preventDefault();
            }
        };
        return IonBackButtonDelegateDirective;
    }());
    /** @nocollapse */ IonBackButtonDelegateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonBackButtonDelegateDirective, deps: [{ token: IonRouterOutlet, optional: true }, { token: NavController }, { token: Config }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ IonBackButtonDelegateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: IonBackButtonDelegateDirective, selector: "ion-back-button", inputs: { defaultHref: "defaultHref", routerAnimation: "routerAnimation" }, host: { listeners: { "click": "onClick($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonBackButtonDelegateDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ion-back-button',
                    }]
            }], ctorParameters: function () {
            return [{ type: IonRouterOutlet, decorators: [{
                            type: i0.Optional
                        }] }, { type: NavController }, { type: Config }];
        }, propDecorators: { defaultHref: [{
                    type: i0.Input
                }], routerAnimation: [{
                    type: i0.Input
                }], onClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });

    exports.NavDelegate = /** @class */ (function () {
        function NavDelegate(ref, resolver, injector, angularDelegate, location) {
            this.el = ref.nativeElement;
            ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);
            proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);
        }
        return NavDelegate;
    }());
    /** @nocollapse */ exports.NavDelegate.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.NavDelegate, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.Injector }, { token: AngularDelegate }, { token: i0__namespace.ViewContainerRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ exports.NavDelegate.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: exports.NavDelegate, selector: "ion-nav", ngImport: i0__namespace });
    exports.NavDelegate = __decorate([
        ProxyCmp({
            inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],
            methods: [
                'push',
                'insert',
                'insertPages',
                'pop',
                'popTo',
                'popToRoot',
                'removeIndex',
                'setRoot',
                'setPages',
                'getActive',
                'getByIndex',
                'canGoBack',
                'getPrevious',
            ],
        })
    ], exports.NavDelegate);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.NavDelegate, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'ion-nav',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.Injector }, { type: AngularDelegate }, { type: i0__namespace.ViewContainerRef }]; } });

    /**
     * Adds support for Ionic routing directions and animations to the base Angular router link directive.
     *
     * When the router link is clicked, the directive will assign the direction and
     * animation so that the routing integration will transition correctly.
     */
    var RouterLinkDelegateDirective = /** @class */ (function () {
        function RouterLinkDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {
            this.locationStrategy = locationStrategy;
            this.navCtrl = navCtrl;
            this.elementRef = elementRef;
            this.router = router;
            this.routerLink = routerLink;
            this.routerDirection = 'forward';
        }
        RouterLinkDelegateDirective.prototype.ngOnInit = function () {
            this.updateTargetUrlAndHref();
        };
        RouterLinkDelegateDirective.prototype.ngOnChanges = function () {
            this.updateTargetUrlAndHref();
        };
        RouterLinkDelegateDirective.prototype.updateTargetUrlAndHref = function () {
            var _a;
            if ((_a = this.routerLink) === null || _a === void 0 ? void 0 : _a.urlTree) {
                var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));
                this.elementRef.nativeElement.href = href;
            }
        };
        /**
         * @internal
         */
        RouterLinkDelegateDirective.prototype.onClick = function (ev) {
            this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);
            /**
             * This prevents the browser from
             * performing a page reload when pressing
             * an Ionic component with routerLink.
             * The page reload interferes with routing
             * and causes ion-back-button to disappear
             * since the local history is wiped on reload.
             */
            ev.preventDefault();
        };
        return RouterLinkDelegateDirective;
    }());
    /** @nocollapse */ RouterLinkDelegateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RouterLinkDelegateDirective, deps: [{ token: i1__namespace.LocationStrategy }, { token: NavController }, { token: i0__namespace.ElementRef }, { token: i3__namespace.Router }, { token: i3__namespace.RouterLink, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ RouterLinkDelegateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: RouterLinkDelegateDirective, selector: ":not(a):not(area)[routerLink]", inputs: { routerDirection: "routerDirection", routerAnimation: "routerAnimation" }, host: { listeners: { "click": "onClick($event)" } }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RouterLinkDelegateDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: ':not(a):not(area)[routerLink]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.LocationStrategy }, { type: NavController }, { type: i0__namespace.ElementRef }, { type: i3__namespace.Router }, { type: i3__namespace.RouterLink, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { routerDirection: [{
                    type: i0.Input
                }], routerAnimation: [{
                    type: i0.Input
                }], onClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event']]
                }] } });
    var RouterLinkWithHrefDelegateDirective = /** @class */ (function () {
        function RouterLinkWithHrefDelegateDirective(locationStrategy, navCtrl, elementRef, router, routerLink) {
            this.locationStrategy = locationStrategy;
            this.navCtrl = navCtrl;
            this.elementRef = elementRef;
            this.router = router;
            this.routerLink = routerLink;
            this.routerDirection = 'forward';
        }
        RouterLinkWithHrefDelegateDirective.prototype.ngOnInit = function () {
            this.updateTargetUrlAndHref();
        };
        RouterLinkWithHrefDelegateDirective.prototype.ngOnChanges = function () {
            this.updateTargetUrlAndHref();
        };
        RouterLinkWithHrefDelegateDirective.prototype.updateTargetUrlAndHref = function () {
            var _a;
            if ((_a = this.routerLink) === null || _a === void 0 ? void 0 : _a.urlTree) {
                var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));
                this.elementRef.nativeElement.href = href;
            }
        };
        /**
         * @internal
         */
        RouterLinkWithHrefDelegateDirective.prototype.onClick = function () {
            this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);
        };
        return RouterLinkWithHrefDelegateDirective;
    }());
    /** @nocollapse */ RouterLinkWithHrefDelegateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RouterLinkWithHrefDelegateDirective, deps: [{ token: i1__namespace.LocationStrategy }, { token: NavController }, { token: i0__namespace.ElementRef }, { token: i3__namespace.Router }, { token: i3__namespace.RouterLink, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ RouterLinkWithHrefDelegateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: RouterLinkWithHrefDelegateDirective, selector: "a[routerLink],area[routerLink]", inputs: { routerDirection: "routerDirection", routerAnimation: "routerAnimation" }, host: { listeners: { "click": "onClick()" } }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: RouterLinkWithHrefDelegateDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'a[routerLink],area[routerLink]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.LocationStrategy }, { type: NavController }, { type: i0__namespace.ElementRef }, { type: i3__namespace.Router }, { type: i3__namespace.RouterLink, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { routerDirection: [{
                    type: i0.Input
                }], routerAnimation: [{
                    type: i0.Input
                }], onClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }] } });

    /**
     * @hidden
     */
    var VirtualFooter = /** @class */ (function () {
        function VirtualFooter(templateRef) {
            this.templateRef = templateRef;
        }
        return VirtualFooter;
    }());
    /** @nocollapse */ VirtualFooter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualFooter, deps: [{ token: i0__namespace.TemplateRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ VirtualFooter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: VirtualFooter, selector: "[virtualFooter]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualFooter, decorators: [{
                type: i0.Directive,
                args: [{ selector: '[virtualFooter]' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }]; } });

    /**
     * @hidden
     */
    var VirtualHeader = /** @class */ (function () {
        function VirtualHeader(templateRef) {
            this.templateRef = templateRef;
        }
        return VirtualHeader;
    }());
    /** @nocollapse */ VirtualHeader.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualHeader, deps: [{ token: i0__namespace.TemplateRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ VirtualHeader.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: VirtualHeader, selector: "[virtualHeader]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualHeader, decorators: [{
                type: i0.Directive,
                args: [{ selector: '[virtualHeader]' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }]; } });

    /**
     * @hidden
     */
    var VirtualItem = /** @class */ (function () {
        function VirtualItem(templateRef, viewContainer) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
        }
        return VirtualItem;
    }());
    /** @nocollapse */ VirtualItem.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualItem, deps: [{ token: i0__namespace.TemplateRef }, { token: i0__namespace.ViewContainerRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ VirtualItem.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.10", type: VirtualItem, selector: "[virtualItem]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: VirtualItem, decorators: [{
                type: i0.Directive,
                args: [{ selector: '[virtualItem]' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }, { type: i0__namespace.ViewContainerRef }]; } });

    exports.IonVirtualScroll = /** @class */ (function () {
        function IonVirtualScroll(z, iterableDiffers, elementRef) {
            this.z = z;
            this.iterableDiffers = iterableDiffers;
            this.refMap = new WeakMap();
            this.el = elementRef.nativeElement;
            this.el.nodeRender = this.nodeRender.bind(this);
        }
        IonVirtualScroll.prototype.ngOnChanges = function (changes) {
            if (this.trackBy && 'items' in changes) {
                // React on virtualScroll changes only once all inputs have been initialized
                var value = changes['items'].currentValue;
                if (this.differ === undefined && value != null) {
                    try {
                        this.differ = this.iterableDiffers.find(value).create(this.trackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object '" + value + "'. VirtualScroll only supports binding to Iterables such as Arrays.");
                    }
                }
            }
        };
        IonVirtualScroll.prototype.ngDoCheck = function () {
            // and if there actually are changes
            var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;
            if (changes === null) {
                return;
            }
            // TODO: optimize
            this.checkRange(0);
        };
        IonVirtualScroll.prototype.nodeRender = function (el, cell, index) {
            var _this = this;
            return this.z.run(function () {
                var node;
                if (!el) {
                    node = _this.itmTmp.viewContainer.createEmbeddedView(_this.getComponent(cell.type), { $implicit: cell.value, index: index }, index);
                    el = getElement(node);
                    _this.refMap.set(el, node);
                }
                else {
                    node = _this.refMap.get(el);
                    var ctx = node.context;
                    ctx.$implicit = cell.value;
                    ctx.index = cell.index;
                }
                // run sync change detections
                node.detectChanges();
                return el;
            });
        };
        IonVirtualScroll.prototype.getComponent = function (type) {
            switch (type) {
                case 'item': return this.itmTmp.templateRef;
                case 'header': return this.hdrTmp.templateRef;
                case 'footer': return this.ftrTmp.templateRef;
                default: throw new Error('template for virtual item was not provided');
            }
        };
        return IonVirtualScroll;
    }());
    /** @nocollapse */ exports.IonVirtualScroll.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonVirtualScroll, deps: [{ token: i0__namespace.NgZone }, { token: i0__namespace.IterableDiffers }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonVirtualScroll.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonVirtualScroll, selector: "ion-virtual-scroll", inputs: { approxItemHeight: "approxItemHeight", approxHeaderHeight: "approxHeaderHeight", approxFooterHeight: "approxFooterHeight", headerFn: "headerFn", footerFn: "footerFn", items: "items", itemHeight: "itemHeight", headerHeight: "headerHeight", footerHeight: "footerHeight", trackBy: "trackBy" }, queries: [{ propertyName: "itmTmp", first: true, predicate: VirtualItem, descendants: true }, { propertyName: "hdrTmp", first: true, predicate: VirtualHeader, descendants: true }, { propertyName: "ftrTmp", first: true, predicate: VirtualFooter, descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonVirtualScroll = __decorate([
        ProxyCmp({
            inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight'],
            methods: ['checkEnd', 'checkRange', 'positionForItem']
        })
    ], exports.IonVirtualScroll);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonVirtualScroll, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-virtual-scroll',
                        template: '<ng-content></ng-content>',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        inputs: [
                            'approxItemHeight',
                            'approxHeaderHeight',
                            'approxFooterHeight',
                            'headerFn',
                            'footerFn',
                            'items',
                            'itemHeight',
                            'headerHeight',
                            'footerHeight',
                            'trackBy'
                        ]
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }, { type: i0__namespace.IterableDiffers }, { type: i0__namespace.ElementRef }]; }, propDecorators: { itmTmp: [{
                    type: i0.ContentChild,
                    args: [VirtualItem, { static: false }]
                }], hdrTmp: [{
                    type: i0.ContentChild,
                    args: [VirtualHeader, { static: false }]
                }], ftrTmp: [{
                    type: i0.ContentChild,
                    args: [VirtualFooter, { static: false }]
                }] } });
    var getElement = function (view) {
        var rootNodes = view.rootNodes;
        for (var i = 0; i < rootNodes.length; i++) {
            if (rootNodes[i].nodeType === 1) {
                return rootNodes[i];
            }
        }
        throw new Error('virtual element was not created');
    };

    exports.IonModal = /** @class */ (function () {
        function IonModal(c, r, z) {
            var _this = this;
            this.z = z;
            this.isCmpOpen = false;
            this.el = r.nativeElement;
            this.el.addEventListener('willPresent', function () {
                _this.isCmpOpen = true;
                c.detectChanges();
            });
            this.el.addEventListener('didDismiss', function () {
                _this.isCmpOpen = false;
                c.detectChanges();
            });
            proxyOutputs(this, this.el, [
                'ionModalDidPresent',
                'ionModalWillPresent',
                'ionModalWillDismiss',
                'ionModalDidDismiss',
                'ionBreakpointDidChange',
                'didPresent',
                'willPresent',
                'willDismiss',
                'didDismiss',
            ]);
        }
        return IonModal;
    }());
    /** @nocollapse */ exports.IonModal.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonModal, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonModal.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonModal, selector: "ion-modal", inputs: { animated: "animated", backdropBreakpoint: "backdropBreakpoint", backdropDismiss: "backdropDismiss", breakpoints: "breakpoints", canDismiss: "canDismiss", cssClass: "cssClass", enterAnimation: "enterAnimation", event: "event", handle: "handle", initialBreakpoint: "initialBreakpoint", isOpen: "isOpen", keyboardClose: "keyboardClose", leaveAnimation: "leaveAnimation", mode: "mode", presentingElement: "presentingElement", showBackdrop: "showBackdrop", swipeToClose: "swipeToClose", translucent: "translucent", trigger: "trigger" }, queries: [{ propertyName: "template", first: true, predicate: i0.TemplateRef, descendants: true }], ngImport: i0__namespace, template: "<div class=\"ion-page\" *ngIf=\"isCmpOpen\"><ng-container [ngTemplateOutlet]=\"template\"></ng-container></div>", isInline: true, directives: [{ type: i1__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonModal = __decorate([
        ProxyCmp({
            inputs: [
                'animated',
                'backdropBreakpoint',
                'backdropDismiss',
                'breakpoints',
                'canDismiss',
                'cssClass',
                'enterAnimation',
                'event',
                'handle',
                'initialBreakpoint',
                'isOpen',
                'keyboardClose',
                'leaveAnimation',
                'mode',
                'presentingElement',
                'showBackdrop',
                'swipeToClose',
                'translucent',
                'trigger',
            ],
            methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'setCurrentBreakpoint', 'getCurrentBreakpoint'],
        })
    ], exports.IonModal);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonModal, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-modal',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: "<div class=\"ion-page\" *ngIf=\"isCmpOpen\"><ng-container [ngTemplateOutlet]=\"template\"></ng-container></div>",
                        inputs: [
                            'animated',
                            'backdropBreakpoint',
                            'backdropDismiss',
                            'breakpoints',
                            'canDismiss',
                            'cssClass',
                            'enterAnimation',
                            'event',
                            'handle',
                            'initialBreakpoint',
                            'isOpen',
                            'keyboardClose',
                            'leaveAnimation',
                            'mode',
                            'presentingElement',
                            'showBackdrop',
                            'swipeToClose',
                            'translucent',
                            'trigger',
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; }, propDecorators: { template: [{
                    type: i0.ContentChild,
                    args: [i0.TemplateRef, { static: false }]
                }] } });

    exports.IonPopover = /** @class */ (function () {
        function IonPopover(c, r, z) {
            var _this = this;
            this.z = z;
            this.isCmpOpen = false;
            this.el = r.nativeElement;
            this.el.addEventListener('willPresent', function () {
                _this.isCmpOpen = true;
                c.detectChanges();
            });
            this.el.addEventListener('didDismiss', function () {
                _this.isCmpOpen = false;
                c.detectChanges();
            });
            proxyOutputs(this, this.el, [
                'ionPopoverDidPresent',
                'ionPopoverWillPresent',
                'ionPopoverWillDismiss',
                'ionPopoverDidDismiss',
                'didPresent',
                'willPresent',
                'willDismiss',
                'didDismiss',
            ]);
        }
        return IonPopover;
    }());
    /** @nocollapse */ exports.IonPopover.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonPopover, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Component });
    /** @nocollapse */ exports.IonPopover.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.10", type: exports.IonPopover, selector: "ion-popover", inputs: { alignment: "alignment", animated: "animated", arrow: "arrow", backdropDismiss: "backdropDismiss", cssClass: "cssClass", dismissOnSelect: "dismissOnSelect", enterAnimation: "enterAnimation", event: "event", isOpen: "isOpen", keyboardClose: "keyboardClose", leaveAnimation: "leaveAnimation", mode: "mode", showBackdrop: "showBackdrop", translucent: "translucent", trigger: "trigger", triggerAction: "triggerAction", reference: "reference", size: "size", side: "side" }, queries: [{ propertyName: "template", first: true, predicate: i0.TemplateRef, descendants: true }], ngImport: i0__namespace, template: "<ng-container [ngTemplateOutlet]=\"template\" *ngIf=\"isCmpOpen\"></ng-container>", isInline: true, directives: [{ type: i1__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    exports.IonPopover = __decorate([
        ProxyCmp({
            inputs: [
                'alignment',
                'animated',
                'arrow',
                'backdropDismiss',
                'cssClass',
                'dismissOnSelect',
                'enterAnimation',
                'event',
                'isOpen',
                'keyboardClose',
                'leaveAnimation',
                'mode',
                'showBackdrop',
                'translucent',
                'trigger',
                'triggerAction',
                'reference',
                'size',
                'side',
            ],
            methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'],
        })
    ], exports.IonPopover);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: exports.IonPopover, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'ion-popover',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        template: "<ng-container [ngTemplateOutlet]=\"template\" *ngIf=\"isCmpOpen\"></ng-container>",
                        inputs: [
                            'alignment',
                            'animated',
                            'arrow',
                            'backdropDismiss',
                            'cssClass',
                            'dismissOnSelect',
                            'enterAnimation',
                            'event',
                            'isOpen',
                            'keyboardClose',
                            'leaveAnimation',
                            'mode',
                            'showBackdrop',
                            'translucent',
                            'trigger',
                            'triggerAction',
                            'reference',
                            'size',
                            'side',
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }]; }, propDecorators: { template: [{
                    type: i0.ContentChild,
                    args: [i0.TemplateRef, { static: false }]
                }] } });

    var OverlayBaseController = /** @class */ (function () {
        function OverlayBaseController(ctrl) {
            this.ctrl = ctrl;
        }
        /**
         * Creates a new overlay
         */
        OverlayBaseController.prototype.create = function (opts) {
            // TODO: next major release opts is not optional
            return this.ctrl.create((opts || {}));
        };
        /**
         * When `id` is not provided, it dismisses the top overlay.
         */
        OverlayBaseController.prototype.dismiss = function (data, role, id) {
            return this.ctrl.dismiss(data, role, id);
        };
        /**
         * Returns the top overlay.
         */
        OverlayBaseController.prototype.getTop = function () {
            return this.ctrl.getTop();
        };
        return OverlayBaseController;
    }());

    var ActionSheetController = /** @class */ (function (_super) {
        __extends(ActionSheetController, _super);
        function ActionSheetController() {
            return _super.call(this, core.actionSheetController) || this;
        }
        return ActionSheetController;
    }(OverlayBaseController));
    /** @nocollapse */ ActionSheetController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ActionSheetController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ ActionSheetController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ActionSheetController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ActionSheetController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var AlertController = /** @class */ (function (_super) {
        __extends(AlertController, _super);
        function AlertController() {
            return _super.call(this, core.alertController) || this;
        }
        return AlertController;
    }(OverlayBaseController));
    /** @nocollapse */ AlertController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AlertController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ AlertController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AlertController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AlertController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var LoadingController = /** @class */ (function (_super) {
        __extends(LoadingController, _super);
        function LoadingController() {
            return _super.call(this, core.loadingController) || this;
        }
        return LoadingController;
    }(OverlayBaseController));
    /** @nocollapse */ LoadingController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoadingController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ LoadingController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoadingController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: LoadingController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var MenuController = /** @class */ (function () {
        function MenuController() {
        }
        /**
         * Programmatically open the Menu.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return returns a promise when the menu is fully opened
         */
        MenuController.prototype.open = function (menuId) {
            return core.menuController.open(menuId);
        };
        /**
         * Programmatically close the Menu. If no `menuId` is given as the first
         * argument then it'll close any menu which is open. If a `menuId`
         * is given then it'll close that exact menu.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return returns a promise when the menu is fully closed
         */
        MenuController.prototype.close = function (menuId) {
            return core.menuController.close(menuId);
        };
        /**
         * Toggle the menu. If it's closed, it will open, and if opened, it
         * will close.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return returns a promise when the menu has been toggled
         */
        MenuController.prototype.toggle = function (menuId) {
            return core.menuController.toggle(menuId);
        };
        /**
         * Used to enable or disable a menu. For example, there could be multiple
         * left menus, but only one of them should be able to be opened at the same
         * time. If there are multiple menus on the same side, then enabling one menu
         * will also automatically disable all the others that are on the same side.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return Returns the instance of the menu, which is useful for chaining.
         */
        MenuController.prototype.enable = function (shouldEnable, menuId) {
            return core.menuController.enable(shouldEnable, menuId);
        };
        /**
         * Used to enable or disable the ability to swipe open the menu.
         * @param shouldEnable  True if it should be swipe-able, false if not.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return Returns the instance of the menu, which is useful for chaining.
         */
        MenuController.prototype.swipeGesture = function (shouldEnable, menuId) {
            return core.menuController.swipeGesture(shouldEnable, menuId);
        };
        /**
         * @param [menuId] Optionally get the menu by its id, or side.
         * @return Returns true if the specified menu is currently open, otherwise false.
         * If the menuId is not specified, it returns true if ANY menu is currenly open.
         */
        MenuController.prototype.isOpen = function (menuId) {
            return core.menuController.isOpen(menuId);
        };
        /**
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return Returns true if the menu is currently enabled, otherwise false.
         */
        MenuController.prototype.isEnabled = function (menuId) {
            return core.menuController.isEnabled(menuId);
        };
        /**
         * Used to get a menu instance. If a `menuId` is not provided then it'll
         * return the first menu found. If a `menuId` is `left` or `right`, then
         * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
         * provided, then it'll try to find the menu using the menu's `id`
         * property. If a menu is not found then it'll return `null`.
         * @param [menuId]  Optionally get the menu by its id, or side.
         * @return Returns the instance of the menu if found, otherwise `null`.
         */
        MenuController.prototype.get = function (menuId) {
            return core.menuController.get(menuId);
        };
        /**
         * @return Returns the instance of the menu already opened, otherwise `null`.
         */
        MenuController.prototype.getOpen = function () {
            return core.menuController.getOpen();
        };
        /**
         * @return Returns an array of all menu instances.
         */
        MenuController.prototype.getMenus = function () {
            return core.menuController.getMenus();
        };
        return MenuController;
    }());
    /** @nocollapse */ MenuController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MenuController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ MenuController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MenuController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: MenuController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var PickerController = /** @class */ (function (_super) {
        __extends(PickerController, _super);
        function PickerController() {
            return _super.call(this, core.pickerController) || this;
        }
        return PickerController;
    }(OverlayBaseController));
    /** @nocollapse */ PickerController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PickerController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ PickerController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PickerController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PickerController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var ModalController = /** @class */ (function (_super) {
        __extends(ModalController, _super);
        function ModalController(angularDelegate, resolver, injector, 
        // TODO: FW-1641: Migrate to Angular's version once Angular 13 is dropped
        environmentInjector) {
            var _this = _super.call(this, core.modalController) || this;
            _this.angularDelegate = angularDelegate;
            _this.resolver = resolver;
            _this.injector = injector;
            _this.environmentInjector = environmentInjector;
            return _this;
        }
        ModalController.prototype.create = function (opts) {
            var _a;
            return _super.prototype.create.call(this, Object.assign(Object.assign({}, opts), { delegate: this.angularDelegate.create((_a = this.resolver) !== null && _a !== void 0 ? _a : this.environmentInjector, this.injector) }));
        };
        return ModalController;
    }(OverlayBaseController));
    /** @nocollapse */ ModalController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ModalController, deps: [{ token: AngularDelegate }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.Injector }, { token: EnvironmentInjector, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ ModalController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ModalController });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ModalController, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: AngularDelegate }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.Injector }, { type: EnvironmentInjector, decorators: [{
                            type: i0.Optional
                        }] }];
        } });

    var PopoverController = /** @class */ (function (_super) {
        __extends(PopoverController, _super);
        function PopoverController(angularDelegate, resolver, injector, 
        // TODO: FW-1641: Migrate to Angular's version once Angular 13 is dropped
        environmentInjector) {
            var _this = _super.call(this, core.popoverController) || this;
            _this.angularDelegate = angularDelegate;
            _this.resolver = resolver;
            _this.injector = injector;
            _this.environmentInjector = environmentInjector;
            return _this;
        }
        PopoverController.prototype.create = function (opts) {
            var _a;
            return _super.prototype.create.call(this, Object.assign(Object.assign({}, opts), { delegate: this.angularDelegate.create((_a = this.resolver) !== null && _a !== void 0 ? _a : this.environmentInjector, this.injector) }));
        };
        return PopoverController;
    }(OverlayBaseController));
    /** @nocollapse */ PopoverController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PopoverController, deps: [{ token: AngularDelegate }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.Injector }, { token: EnvironmentInjector, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ PopoverController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PopoverController });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: PopoverController, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: AngularDelegate }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.Injector }, { type: EnvironmentInjector, decorators: [{
                            type: i0.Optional
                        }] }];
        } });

    var ToastController = /** @class */ (function (_super) {
        __extends(ToastController, _super);
        function ToastController() {
            return _super.call(this, core.toastController) || this;
        }
        return ToastController;
    }(OverlayBaseController));
    /** @nocollapse */ ToastController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ToastController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ ToastController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ToastController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: ToastController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var DomController = /** @class */ (function () {
        function DomController() {
        }
        /**
         * Schedules a task to run during the READ phase of the next frame.
         * This task should only read the DOM, but never modify it.
         */
        DomController.prototype.read = function (cb) {
            getQueue().read(cb);
        };
        /**
         * Schedules a task to run during the WRITE phase of the next frame.
         * This task should write the DOM, but never READ it.
         */
        DomController.prototype.write = function (cb) {
            getQueue().write(cb);
        };
        return DomController;
    }());
    /** @nocollapse */ DomController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DomController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ DomController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DomController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: DomController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });
    var getQueue = function () {
        var win = typeof window !== 'undefined' ? window : null;
        if (win != null) {
            var Ionic = win.Ionic;
            if (Ionic === null || Ionic === void 0 ? void 0 : Ionic.queue) {
                return Ionic.queue;
            }
            return {
                read: function (cb) { return win.requestAnimationFrame(cb); },
                write: function (cb) { return win.requestAnimationFrame(cb); },
            };
        }
        return {
            read: function (cb) { return cb(); },
            write: function (cb) { return cb(); },
        };
    };

    var AnimationController = /** @class */ (function () {
        function AnimationController() {
        }
        /**
         * Create a new animation
         */
        AnimationController.prototype.create = function (animationId) {
            return core.createAnimation(animationId);
        };
        /**
         * EXPERIMENTAL
         *
         * Given a progression and a cubic bezier function,
         * this utility returns the time value(s) at which the
         * cubic bezier reaches the given time progression.
         *
         * If the cubic bezier never reaches the progression
         * the result will be an empty array.
         *
         * This is most useful for switching between easing curves
         * when doing a gesture animation (i.e. going from linear easing
         * during a drag, to another easing when `progressEnd` is called)
         */
        AnimationController.prototype.easingTime = function (p0, p1, p2, p3, progression) {
            return core.getTimeGivenProgression(p0, p1, p2, p3, progression);
        };
        return AnimationController;
    }());
    /** @nocollapse */ AnimationController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationController, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ AnimationController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: AnimationController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var GestureController = /** @class */ (function () {
        function GestureController(zone) {
            this.zone = zone;
        }
        /**
         * Create a new gesture
         */
        GestureController.prototype.create = function (opts, runInsideAngularZone) {
            var _this = this;
            if (runInsideAngularZone === void 0) { runInsideAngularZone = false; }
            if (runInsideAngularZone) {
                Object.getOwnPropertyNames(opts).forEach(function (key) {
                    if (typeof opts[key] === 'function') {
                        var fn_1 = opts[key];
                        opts[key] = function () {
                            var props = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                props[_i] = arguments[_i];
                            }
                            return _this.zone.run(function () { return fn_1.apply(void 0, __spreadArray([], __read(props))); });
                        };
                    }
                });
            }
            return core.createGesture(opts);
        };
        return GestureController;
    }());
    /** @nocollapse */ GestureController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: GestureController, deps: [{ token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ GestureController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: GestureController, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: GestureController, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }]; } });

    var IonicRouteStrategy = /** @class */ (function () {
        function IonicRouteStrategy() {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        IonicRouteStrategy.prototype.shouldDetach = function (_route) {
            return false;
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        IonicRouteStrategy.prototype.shouldAttach = function (_route) {
            return false;
        };
        IonicRouteStrategy.prototype.store = function (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _route, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _detachedTree) {
            return;
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        IonicRouteStrategy.prototype.retrieve = function (_route) {
            return null;
        };
        IonicRouteStrategy.prototype.shouldReuseRoute = function (future, curr) {
            var e_1, _a;
            if (future.routeConfig !== curr.routeConfig) {
                return false;
            }
            // checking router params
            var futureParams = future.params;
            var currentParams = curr.params;
            var keysA = Object.keys(futureParams);
            var keysB = Object.keys(currentParams);
            if (keysA.length !== keysB.length) {
                return false;
            }
            try {
                // Test for A's keys different from B.
                for (var keysA_1 = __values(keysA), keysA_1_1 = keysA_1.next(); !keysA_1_1.done; keysA_1_1 = keysA_1.next()) {
                    var key = keysA_1_1.value;
                    if (currentParams[key] !== futureParams[key]) {
                        return false;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keysA_1_1 && !keysA_1_1.done && (_a = keysA_1.return)) _a.call(keysA_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return true;
        };
        return IonicRouteStrategy;
    }());

    var appInitialize = function (config, doc, zone) {
        return function () {
            var win = doc.defaultView;
            if (win && typeof window !== 'undefined') {
                core.setupConfig(Object.assign(Object.assign({}, config), { _zoneGate: function (h) { return zone.run(h); } }));
                var aelFn_1 = '__zone_symbol__addEventListener' in doc.body ? '__zone_symbol__addEventListener' : 'addEventListener';
                return loader.applyPolyfills().then(function () {
                    return loader.defineCustomElements(win, {
                        exclude: ['ion-tabs', 'ion-tab'],
                        syncQueue: true,
                        raf: raf,
                        jmp: function (h) { return zone.runOutsideAngular(h); },
                        ael: function (elm, eventName, cb, opts) {
                            elm[aelFn_1](eventName, cb, opts);
                        },
                        rel: function (elm, eventName, cb, opts) {
                            elm.removeEventListener(eventName, cb, opts);
                        },
                    });
                });
            }
        };
    };

    var DECLARATIONS = [
        // proxies
        exports.IonAccordion,
        exports.IonAccordionGroup,
        exports.IonApp,
        exports.IonAvatar,
        exports.IonBackButton,
        exports.IonBackdrop,
        exports.IonBadge,
        exports.IonBreadcrumb,
        exports.IonBreadcrumbs,
        exports.IonButton,
        exports.IonButtons,
        exports.IonCard,
        exports.IonCardContent,
        exports.IonCardHeader,
        exports.IonCardSubtitle,
        exports.IonCardTitle,
        exports.IonCheckbox,
        exports.IonChip,
        exports.IonCol,
        exports.IonContent,
        exports.IonDatetime,
        exports.IonFab,
        exports.IonFabButton,
        exports.IonFabList,
        exports.IonFooter,
        exports.IonGrid,
        exports.IonHeader,
        exports.IonIcon,
        exports.IonImg,
        exports.IonInfiniteScroll,
        exports.IonInfiniteScrollContent,
        exports.IonInput,
        exports.IonItem,
        exports.IonItemDivider,
        exports.IonItemGroup,
        exports.IonItemOption,
        exports.IonItemOptions,
        exports.IonItemSliding,
        exports.IonLabel,
        exports.IonList,
        exports.IonListHeader,
        exports.IonMenu,
        exports.IonMenuButton,
        exports.IonMenuToggle,
        exports.IonModal,
        exports.IonNav,
        exports.IonNavLink,
        exports.IonNote,
        exports.IonPopover,
        exports.IonProgressBar,
        exports.IonRadio,
        exports.IonRadioGroup,
        exports.IonRange,
        exports.IonRefresher,
        exports.IonRefresherContent,
        exports.IonReorder,
        exports.IonReorderGroup,
        exports.IonRippleEffect,
        exports.IonRow,
        exports.IonSearchbar,
        exports.IonSegment,
        exports.IonSegmentButton,
        exports.IonSelect,
        exports.IonSelectOption,
        exports.IonSkeletonText,
        exports.IonSlide,
        exports.IonSlides,
        exports.IonSpinner,
        exports.IonSplitPane,
        exports.IonTabBar,
        exports.IonTabButton,
        exports.IonText,
        exports.IonTextarea,
        exports.IonThumbnail,
        exports.IonToggle,
        exports.IonToolbar,
        exports.IonTitle,
        IonTabs,
        // ngModel accessors
        BooleanValueAccessorDirective,
        NumericValueAccessorDirective,
        RadioValueAccessorDirective,
        SelectValueAccessorDirective,
        TextValueAccessorDirective,
        // navigation
        IonRouterOutlet,
        IonBackButtonDelegateDirective,
        exports.NavDelegate,
        RouterLinkDelegateDirective,
        RouterLinkWithHrefDelegateDirective,
        // virtual scroll
        VirtualFooter,
        VirtualHeader,
        VirtualItem,
        exports.IonVirtualScroll,
    ];
    var IonicModule = /** @class */ (function () {
        function IonicModule() {
        }
        IonicModule.forRoot = function (config) {
            return {
                ngModule: IonicModule,
                providers: [
                    {
                        provide: ConfigToken,
                        useValue: config,
                    },
                    {
                        provide: i0.APP_INITIALIZER,
                        useFactory: appInitialize,
                        multi: true,
                        deps: [ConfigToken, i1.DOCUMENT, i0.NgZone],
                    },
                ],
            };
        };
        return IonicModule;
    }());
    /** @nocollapse */ IonicModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonicModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ IonicModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonicModule, declarations: [
            // proxies
            exports.IonAccordion,
            exports.IonAccordionGroup,
            exports.IonApp,
            exports.IonAvatar,
            exports.IonBackButton,
            exports.IonBackdrop,
            exports.IonBadge,
            exports.IonBreadcrumb,
            exports.IonBreadcrumbs,
            exports.IonButton,
            exports.IonButtons,
            exports.IonCard,
            exports.IonCardContent,
            exports.IonCardHeader,
            exports.IonCardSubtitle,
            exports.IonCardTitle,
            exports.IonCheckbox,
            exports.IonChip,
            exports.IonCol,
            exports.IonContent,
            exports.IonDatetime,
            exports.IonFab,
            exports.IonFabButton,
            exports.IonFabList,
            exports.IonFooter,
            exports.IonGrid,
            exports.IonHeader,
            exports.IonIcon,
            exports.IonImg,
            exports.IonInfiniteScroll,
            exports.IonInfiniteScrollContent,
            exports.IonInput,
            exports.IonItem,
            exports.IonItemDivider,
            exports.IonItemGroup,
            exports.IonItemOption,
            exports.IonItemOptions,
            exports.IonItemSliding,
            exports.IonLabel,
            exports.IonList,
            exports.IonListHeader,
            exports.IonMenu,
            exports.IonMenuButton,
            exports.IonMenuToggle,
            exports.IonModal,
            exports.IonNav,
            exports.IonNavLink,
            exports.IonNote,
            exports.IonPopover,
            exports.IonProgressBar,
            exports.IonRadio,
            exports.IonRadioGroup,
            exports.IonRange,
            exports.IonRefresher,
            exports.IonRefresherContent,
            exports.IonReorder,
            exports.IonReorderGroup,
            exports.IonRippleEffect,
            exports.IonRow,
            exports.IonSearchbar,
            exports.IonSegment,
            exports.IonSegmentButton,
            exports.IonSelect,
            exports.IonSelectOption,
            exports.IonSkeletonText,
            exports.IonSlide,
            exports.IonSlides,
            exports.IonSpinner,
            exports.IonSplitPane,
            exports.IonTabBar,
            exports.IonTabButton,
            exports.IonText,
            exports.IonTextarea,
            exports.IonThumbnail,
            exports.IonToggle,
            exports.IonToolbar,
            exports.IonTitle,
            IonTabs,
            // ngModel accessors
            BooleanValueAccessorDirective,
            NumericValueAccessorDirective,
            RadioValueAccessorDirective,
            SelectValueAccessorDirective,
            TextValueAccessorDirective,
            // navigation
            IonRouterOutlet,
            IonBackButtonDelegateDirective,
            exports.NavDelegate,
            RouterLinkDelegateDirective,
            RouterLinkWithHrefDelegateDirective,
            // virtual scroll
            VirtualFooter,
            VirtualHeader,
            VirtualItem,
            exports.IonVirtualScroll
        ], imports: [i1.CommonModule], exports: [
            // proxies
            exports.IonAccordion,
            exports.IonAccordionGroup,
            exports.IonApp,
            exports.IonAvatar,
            exports.IonBackButton,
            exports.IonBackdrop,
            exports.IonBadge,
            exports.IonBreadcrumb,
            exports.IonBreadcrumbs,
            exports.IonButton,
            exports.IonButtons,
            exports.IonCard,
            exports.IonCardContent,
            exports.IonCardHeader,
            exports.IonCardSubtitle,
            exports.IonCardTitle,
            exports.IonCheckbox,
            exports.IonChip,
            exports.IonCol,
            exports.IonContent,
            exports.IonDatetime,
            exports.IonFab,
            exports.IonFabButton,
            exports.IonFabList,
            exports.IonFooter,
            exports.IonGrid,
            exports.IonHeader,
            exports.IonIcon,
            exports.IonImg,
            exports.IonInfiniteScroll,
            exports.IonInfiniteScrollContent,
            exports.IonInput,
            exports.IonItem,
            exports.IonItemDivider,
            exports.IonItemGroup,
            exports.IonItemOption,
            exports.IonItemOptions,
            exports.IonItemSliding,
            exports.IonLabel,
            exports.IonList,
            exports.IonListHeader,
            exports.IonMenu,
            exports.IonMenuButton,
            exports.IonMenuToggle,
            exports.IonModal,
            exports.IonNav,
            exports.IonNavLink,
            exports.IonNote,
            exports.IonPopover,
            exports.IonProgressBar,
            exports.IonRadio,
            exports.IonRadioGroup,
            exports.IonRange,
            exports.IonRefresher,
            exports.IonRefresherContent,
            exports.IonReorder,
            exports.IonReorderGroup,
            exports.IonRippleEffect,
            exports.IonRow,
            exports.IonSearchbar,
            exports.IonSegment,
            exports.IonSegmentButton,
            exports.IonSelect,
            exports.IonSelectOption,
            exports.IonSkeletonText,
            exports.IonSlide,
            exports.IonSlides,
            exports.IonSpinner,
            exports.IonSplitPane,
            exports.IonTabBar,
            exports.IonTabButton,
            exports.IonText,
            exports.IonTextarea,
            exports.IonThumbnail,
            exports.IonToggle,
            exports.IonToolbar,
            exports.IonTitle,
            IonTabs,
            // ngModel accessors
            BooleanValueAccessorDirective,
            NumericValueAccessorDirective,
            RadioValueAccessorDirective,
            SelectValueAccessorDirective,
            TextValueAccessorDirective,
            // navigation
            IonRouterOutlet,
            IonBackButtonDelegateDirective,
            exports.NavDelegate,
            RouterLinkDelegateDirective,
            RouterLinkWithHrefDelegateDirective,
            // virtual scroll
            VirtualFooter,
            VirtualHeader,
            VirtualItem,
            exports.IonVirtualScroll
        ] });
    /** @nocollapse */ IonicModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonicModule, providers: [AngularDelegate, ModalController, PopoverController], imports: [[i1.CommonModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.10", ngImport: i0__namespace, type: IonicModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: DECLARATIONS,
                        exports: DECLARATIONS,
                        providers: [AngularDelegate, ModalController, PopoverController],
                        imports: [i1.CommonModule],
                    }]
            }] });

    // DIRECTIVES

    /**
     * Generated bundle index. Do not edit.
     */

    Object.defineProperty(exports, 'IonicSafeString', {
        enumerable: true,
        get: function () { return core.IonicSafeString; }
    });
    Object.defineProperty(exports, 'IonicSlides', {
        enumerable: true,
        get: function () { return core.IonicSlides; }
    });
    Object.defineProperty(exports, 'IonicSwiper', {
        enumerable: true,
        get: function () { return core.IonicSwiper; }
    });
    Object.defineProperty(exports, 'createAnimation', {
        enumerable: true,
        get: function () { return core.createAnimation; }
    });
    Object.defineProperty(exports, 'createGesture', {
        enumerable: true,
        get: function () { return core.createGesture; }
    });
    Object.defineProperty(exports, 'getPlatforms', {
        enumerable: true,
        get: function () { return core.getPlatforms; }
    });
    Object.defineProperty(exports, 'getTimeGivenProgression', {
        enumerable: true,
        get: function () { return core.getTimeGivenProgression; }
    });
    Object.defineProperty(exports, 'iosTransitionAnimation', {
        enumerable: true,
        get: function () { return core.iosTransitionAnimation; }
    });
    Object.defineProperty(exports, 'isPlatform', {
        enumerable: true,
        get: function () { return core.isPlatform; }
    });
    Object.defineProperty(exports, 'mdTransitionAnimation', {
        enumerable: true,
        get: function () { return core.mdTransitionAnimation; }
    });
    exports.ActionSheetController = ActionSheetController;
    exports.AlertController = AlertController;
    exports.AngularDelegate = AngularDelegate;
    exports.AnimationController = AnimationController;
    exports.BooleanValueAccessor = BooleanValueAccessorDirective;
    exports.Config = Config;
    exports.DomController = DomController;
    exports.GestureController = GestureController;
    exports.IonBackButtonDelegate = IonBackButtonDelegateDirective;
    exports.IonRouterOutlet = IonRouterOutlet;
    exports.IonTabs = IonTabs;
    exports.IonicModule = IonicModule;
    exports.IonicRouteStrategy = IonicRouteStrategy;
    exports.LoadingController = LoadingController;
    exports.MenuController = MenuController;
    exports.ModalController = ModalController;
    exports.NavController = NavController;
    exports.NavParams = NavParams;
    exports.NumericValueAccessor = NumericValueAccessorDirective;
    exports.PickerController = PickerController;
    exports.Platform = Platform;
    exports.PopoverController = PopoverController;
    exports.RadioValueAccessor = RadioValueAccessorDirective;
    exports.RouterLinkDelegate = RouterLinkDelegateDirective;
    exports.RouterLinkWithHrefDelegate = RouterLinkWithHrefDelegateDirective;
    exports.SelectValueAccessor = SelectValueAccessorDirective;
    exports.TextValueAccessor = TextValueAccessorDirective;
    exports.ToastController = ToastController;
    exports.VirtualFooter = VirtualFooter;
    exports.VirtualHeader = VirtualHeader;
    exports.VirtualItem = VirtualItem;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ionic-angular.umd.js.map
